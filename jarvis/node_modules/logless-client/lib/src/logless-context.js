"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var https = require("https");
var util = require("util");
var logless_1 = require("./logless");
var uuid = require("uuid");
var LoglessContext = (function () {
    function LoglessContext(_source) {
        this._source = _source;
        this._queue = [];
    }
    LoglessContext.prototype.wrapCall = function (console, name, type) {
        var self = this;
        var originalCall = console[name];
        if (originalCall.original !== undefined) {
            originalCall = originalCall.original;
        }
        var newCall = function (data) {
            var args = Array.prototype.slice.call(arguments);
            if (args.length > 1) {
                args = args.slice(1);
            }
            else {
                args = null;
            }
            var context = self;
            if (self.usesContinuationLocalStorage()) {
                context = require("continuation-local-storage").getNamespace("Logless").get("context");
                if (context) {
                    context.log(type, data, args);
                }
            }
            else {
                context.log(type, data, args);
            }
            originalCall.apply(this, arguments);
        };
        if (!this.usesContinuationLocalStorage()) {
            newCall.original = originalCall;
        }
        console[name] = newCall;
    };
    LoglessContext.prototype.wrapConsole = function () {
        require("continuation-local-storage").createNamespace("Logless");
        this.wrapCall(console, "error", LogType.ERROR);
        this.wrapCall(console, "info", LogType.INFO);
        this.wrapCall(console, "log", LogType.DEBUG);
        this.wrapCall(console, "warn", LogType.WARN);
    };
    LoglessContext.prototype.captureConsole = function (routine) {
        if (!this.usesContinuationLocalStorage()) {
            return;
        }
        var namespace = require("continuation-local-storage").getNamespace("Logless");
        var self = this;
        namespace.run(function () {
            namespace.set("context", self);
            routine();
        });
    };
    LoglessContext.prototype.onFunctionEvent = function () {
        var self = this;
        this.newTransactionID();
        this.wrapCall(console, "error", LogType.ERROR);
        this.wrapCall(console, "info", LogType.INFO);
        this.wrapCall(console, "log", LogType.DEBUG);
        this.wrapCall(console, "warn", LogType.WARN);
        this._uncaughtExceptionHandler = function (error) {
            console.error(error);
            self.flush();
        };
        process.on("uncaughtException", this._uncaughtExceptionHandler);
    };
    LoglessContext.prototype.onLambdaEvent = function (event, context, wrappedCallback) {
        var self = this;
        this.onFunctionEvent();
        var done = context.done;
        context.done = function (error, result) {
            self.captureResponse(error, result);
            self.flush(function () {
                self.cleanup();
                done.call(context, error, result);
            });
        };
        this.log(LogType.INFO, event, null, ["request"]);
        if (wrappedCallback !== undefined && wrappedCallback !== null) {
            this._callback = function (error, result) {
                self.captureResponse(error, result);
                self.flush(function () {
                    self.cleanup();
                    wrappedCallback.call(this, error, result);
                });
            };
        }
    };
    LoglessContext.prototype.onCloudFunctionEvent = function (request, response) {
        var self = this;
        this.onFunctionEvent();
        var end = response.end;
        response.end = function (data, encoding, callback) {
            var result = data;
            if (response.get("Content-Type").startsWith("application/json")) {
                result = JSON.parse(data.toString());
            }
            self.captureResponse(null, result);
            self.flush(function () {
                self.cleanup();
                end.call(response, data, encoding, callback);
            });
        };
        this.log(LogType.INFO, request.body, null, ["request"]);
    };
    LoglessContext.prototype.callback = function () {
        return this._callback;
    };
    LoglessContext.prototype.log = function (type, data, params, tags) {
        if (data instanceof Error) {
            this.logError(type, data, tags);
        }
        else if (typeof data === "string") {
            var dataString = data;
            if (params !== undefined && params !== null) {
                var allParams = [data];
                for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
                    var param = params_1[_i];
                    allParams.push(param);
                }
                dataString = util.format.apply(this, allParams);
            }
            this._queue.push(new Log(type, dataString, null, tags));
        }
        else {
            if (data === undefined) {
                data = null;
            }
            this._queue.push(new Log(type, data, null, tags));
        }
    };
    LoglessContext.prototype.logError = function (type, error, tags) {
        var message = error.name + ": " + error.message;
        if (error.code !== undefined) {
            message += " code: " + error.code;
        }
        if (error.syscall !== undefined) {
            message += " syscall: " + error.syscall;
        }
        this._queue.push(new Log(type, message, error.stack, tags));
    };
    LoglessContext.prototype.captureResponse = function (error, result) {
        if (error !== undefined && error !== null) {
            this.log(LogType.ERROR, error, null, ["response"]);
        }
        else {
            this.log(LogType.INFO, result, null, ["response"]);
        }
    };
    LoglessContext.prototype.transactionID = function () {
        return this._transactionID;
    };
    LoglessContext.prototype.newTransactionID = function () {
        this._transactionID = uuid.v4();
    };
    LoglessContext.prototype.cleanup = function () {
        process.removeListener("uncaughtException", this._uncaughtExceptionHandler);
    };
    LoglessContext.prototype.flush = function (flushed) {
        if (!this._transactionID) {
            this.newTransactionID();
        }
        var logBatch = {
            source: this._source,
            transaction_id: this.transactionID(),
            logs: new Array()
        };
        for (var _i = 0, _a = this._queue; _i < _a.length; _i++) {
            var log = _a[_i];
            var timestamp = log.timestampAsISOString();
            var logJSON = {
                payload: log.data,
                log_type: LogType[log.type],
                timestamp: timestamp,
            };
            if (log.tags !== undefined && log.tags !== null) {
                logJSON.tags = log.tags;
            }
            if (log.stack !== undefined && log.stack !== null) {
                logJSON.stack = log.stack;
            }
            logBatch.logs.push(logJSON);
        }
        this.transmit(logBatch, flushed);
        this._queue = [];
    };
    LoglessContext.prototype.transmit = function (logBatch, flushed) {
        var dataAsString = JSON.stringify(logBatch);
        var dataLength = Buffer.byteLength(dataAsString);
        var options = {
            host: logless_1.Logless.Domain,
            path: "/v1/receive",
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Content-Length": dataLength,
                "Connection": "keep-alive"
            }
        };
        var httpRequest = https.request(options);
        httpRequest.on("error", function (error) {
            console.error(error.toString());
            if (flushed !== undefined) {
                flushed();
            }
        });
        httpRequest.setNoDelay(true);
        httpRequest.end(dataAsString, null, function () {
            if (flushed !== undefined) {
                flushed();
            }
        });
    };
    LoglessContext.prototype.usesContinuationLocalStorage = function () {
        return process.namespaces !== undefined &&
            require("continuation-local-storage").getNamespace("Logless") !== undefined;
    };
    return LoglessContext;
}());
exports.LoglessContext = LoglessContext;
var LogType;
(function (LogType) {
    LogType[LogType["DEBUG"] = 0] = "DEBUG";
    LogType[LogType["ERROR"] = 1] = "ERROR";
    LogType[LogType["INFO"] = 2] = "INFO";
    LogType[LogType["WARN"] = 3] = "WARN";
})(LogType = exports.LogType || (exports.LogType = {}));
var Log = (function () {
    function Log(type, data, stack, tags) {
        this.type = type;
        this.data = data;
        this.stack = stack;
        this.tags = tags;
        this._timestamp = new Date();
    }
    Log.prototype.timestampAsISOString = function () {
        return this._timestamp.toISOString();
    };
    return Log;
}());
exports.Log = Log;
//# sourceMappingURL=logless-context.js.map