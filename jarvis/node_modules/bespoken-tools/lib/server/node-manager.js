"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var net = require("net");
var node_1 = require("./node");
var socket_handler_1 = require("../core/socket-handler");
var global_1 = require("../core/global");
var logging_helper_1 = require("../core/logging-helper");
var bst_statistics_1 = require("../statistics/bst-statistics");
var Logger = "NODEMGR";
var NodeManager = (function () {
    function NodeManager(port) {
        this.port = port;
        this.host = "0.0.0.0";
        this.onConnect = null;
        this.onNodeRemoved = null;
        this.nodes = {};
    }
    NodeManager.prototype.node = function (nodeID) {
        return this.nodes[nodeID];
    };
    NodeManager.prototype.start = function (callback) {
        var self = this;
        this.server = net.createServer(function (socket) {
            var initialConnection = true;
            var node = null;
            var socketHandler = new socket_handler_1.SocketHandler(socket, function (socketMessage) {
                var strMessage = socketMessage.asString();
                if (initialConnection) {
                    if (!socketMessage.isJSON()) {
                        logging_helper_1.LoggingHelper.error(Logger, "Error on parsing initial message: " + strMessage);
                        socketHandler.disconnect();
                        return;
                    }
                    var connectData = socketMessage.asJSON();
                    node = new node_1.Node(connectData.id, socketHandler);
                    self.nodes[node.id] = node;
                    socketHandler.send(new socket_handler_1.SocketMessage("ACK"));
                    initialConnection = false;
                    if (self.onConnect != null) {
                        self.onConnect(node);
                    }
                    bst_statistics_1.BstStatistics.instance().record(bst_statistics_1.BstCommand.proxy, bst_statistics_1.BstEvent.connect, node.id);
                }
                else if (strMessage === global_1.Global.KeepAliveMessage) {
                    NodeManager.onKeepAliveReceived(node);
                }
                else if (node.handlingRequest()) {
                    node.onReply(socketMessage);
                }
            });
            socketHandler.onCloseCallback = function () {
                if (node !== null) {
                    logging_helper_1.LoggingHelper.info(Logger, "NODE CLOSED: " + node.id);
                    delete self.nodes[node.id];
                    if (self.onNodeRemoved !== undefined && self.onNodeRemoved !== null) {
                        self.onNodeRemoved(node);
                    }
                }
            };
            logging_helper_1.LoggingHelper.info(Logger, "NODE CONNECTED: " + socket.remoteAddress + ":" + socket.remotePort);
        }).listen(this.port, this.host);
        this.server.on("listening", function () {
            if (callback !== undefined && callback !== null) {
                callback();
            }
        });
        logging_helper_1.LoggingHelper.info(Logger, "Listening on " + this.host + ":" + this.port);
    };
    NodeManager.onKeepAliveReceived = function (node) {
        node.socketHandler.send(new socket_handler_1.SocketMessage(global_1.Global.KeepAliveMessage));
    };
    NodeManager.prototype.stop = function (callback) {
        for (var _i = 0, _a = Object.keys(this.nodes); _i < _a.length; _i++) {
            var key = _a[_i];
            var node = this.node(key);
            node.socketHandler.disconnect();
            logging_helper_1.LoggingHelper.info(Logger, "NODE CLOSING: " + node.id);
        }
        this.server.close(function (error) {
            if (error !== undefined) {
                logging_helper_1.LoggingHelper.error(Logger, "ERROR! NodeManager not stopped: " + error);
            }
            else {
                logging_helper_1.LoggingHelper.info(Logger, "STOPPED");
                callback();
            }
        });
    };
    return NodeManager;
}());
exports.NodeManager = NodeManager;
//# sourceMappingURL=node-manager.js.map