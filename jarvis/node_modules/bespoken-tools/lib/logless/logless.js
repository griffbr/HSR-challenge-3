"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logless_context_1 = require("../logless/logless-context");
const logless_context_2 = require("./logless-context");
class Logless {
    static capture(source, handler) {
        if (handler === undefined || handler === null) {
            throw new Error("Handler is null or undefined! This must be passed.");
        }
        return new FunctionWrapper(source, handler).wrappingFunction();
    }
    static logger(source) {
        return new logless_context_1.LoglessContext(source);
    }
    static middleware(source) {
        const context = new logless_context_1.LoglessContext(source);
        if (Logless.captureConsole) {
            context.wrapConsole();
        }
        const capturePayloads = function (request, response, next) {
            context.newTransactionID();
            context.log(logless_context_2.LogType.INFO, request.body, null, ["request"]);
            Logless.wrapResponse(context, response);
            if (Logless.captureConsole) {
                context.captureConsole(function () {
                    next();
                });
            }
            else {
                next();
            }
        };
        const captureError = function (error, request, response, next) {
            context.logError(logless_context_2.LogType.ERROR, error, null);
            next();
        };
        capturePayloads.logger = context;
        captureError.logger = context;
        return new LoglessMiddleware(capturePayloads, captureError);
    }
    static enableConsoleLogging() {
        Logless.captureConsole = true;
    }
    static disableConsoleLogging() {
        Logless.captureConsole = false;
    }
    static wrapResponse(context, response, onFlushed) {
        const originalEnd = response.end;
        response.end = (data, encoding, callback) => {
            let payload = data.toString();
            if (response.getHeader("content-type").startsWith("application/json")) {
                try {
                    payload = JSON.parse(payload);
                }
                catch (e) {
                    console.error("Could not parse JSON: " + payload);
                }
            }
            context.log(logless_context_2.LogType.INFO, payload, null, ["response"]);
            originalEnd.call(response, data, encoding, callback);
            context.flush();
        };
    }
}
Logless.Domain = "logless.bespoken.tools";
Logless.captureConsole = false;
exports.Logless = Logless;
class LoglessMiddleware {
    constructor(requestHandler, errorHandler) {
        this.requestHandler = requestHandler;
        this.errorHandler = errorHandler;
    }
}
exports.LoglessMiddleware = LoglessMiddleware;
class FunctionWrapper {
    constructor(source, wrappedFunction) {
        this.source = source;
        this.wrappedFunction = wrappedFunction;
    }
    handle(arg1, arg2, arg3) {
        if (arg2.awsRequestId !== undefined) {
            this.handleLambda(arg1, arg2, arg3);
        }
        else {
            this.handleCloudFunction(arg1, arg2);
        }
    }
    handleLambda(event, context, callback) {
        const logger = new logless_context_1.LoglessContext(this.source);
        logger.onLambdaEvent(event, context, callback);
        context.logger = logger;
        try {
            this.wrappedFunction.call(this, event, context, logger.callback());
        }
        catch (e) {
            console.error(e);
            logger.flush();
            logger.cleanup();
        }
    }
    handleCloudFunction(request, response) {
        const logger = new logless_context_1.LoglessContext(this.source);
        logger.onCloudFunctionEvent(request, response);
        request.logger = logger;
        try {
            this.wrappedFunction.call(this, request, response);
        }
        catch (e) {
            console.error(e);
            logger.flush();
            logger.cleanup();
        }
    }
    wrappingFunction() {
        let wrapper = this.handle.bind(this);
        return wrapper;
    }
}
//# sourceMappingURL=logless.js.map