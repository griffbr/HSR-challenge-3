"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const https = require("https");
const util = require("util");
const logless_1 = require("./logless");
const uuid = require("uuid");
class LoglessContext {
    constructor(_source) {
        this._source = _source;
        this._queue = [];
    }
    wrapCall(console, name, type) {
        const self = this;
        let originalCall = console[name];
        if (originalCall.original !== undefined) {
            originalCall = originalCall.original;
        }
        let newCall = function (data) {
            let args = Array.prototype.slice.call(arguments);
            if (args.length > 1) {
                args = args.slice(1);
            }
            else {
                args = null;
            }
            let context = self;
            if (self.usesContinuationLocalStorage()) {
                context = require("continuation-local-storage").getNamespace("Logless").get("context");
                if (context) {
                    context.log(type, data, args);
                }
            }
            else {
                context.log(type, data, args);
            }
            originalCall.apply(this, arguments);
        };
        if (!this.usesContinuationLocalStorage()) {
            newCall.original = originalCall;
        }
        console[name] = newCall;
    }
    wrapConsole() {
        require("continuation-local-storage").createNamespace("Logless");
        this.wrapCall(console, "error", LogType.ERROR);
        this.wrapCall(console, "info", LogType.INFO);
        this.wrapCall(console, "log", LogType.DEBUG);
        this.wrapCall(console, "warn", LogType.WARN);
    }
    captureConsole(routine) {
        if (!this.usesContinuationLocalStorage()) {
            return;
        }
        let namespace = require("continuation-local-storage").getNamespace("Logless");
        let self = this;
        namespace.run(function () {
            namespace.set("context", self);
            routine();
        });
    }
    onFunctionEvent() {
        const self = this;
        this.newTransactionID();
        this.wrapCall(console, "error", LogType.ERROR);
        this.wrapCall(console, "info", LogType.INFO);
        this.wrapCall(console, "log", LogType.DEBUG);
        this.wrapCall(console, "warn", LogType.WARN);
        this._uncaughtExceptionHandler = function (error) {
            console.error(error);
            self.flush();
        };
        process.on("uncaughtException", this._uncaughtExceptionHandler);
    }
    onLambdaEvent(event, context, wrappedCallback) {
        const self = this;
        this.onFunctionEvent();
        const done = context.done;
        context.done = function (error, result) {
            self.captureResponse(error, result);
            self.flush(function () {
                self.cleanup();
                done.call(context, error, result);
            });
        };
        this.log(LogType.INFO, event, null, ["request"]);
        if (wrappedCallback !== undefined && wrappedCallback !== null) {
            this._callback = function (error, result) {
                self.captureResponse(error, result);
                self.flush(function () {
                    self.cleanup();
                    wrappedCallback.call(this, error, result);
                });
            };
        }
    }
    onCloudFunctionEvent(request, response) {
        const self = this;
        this.onFunctionEvent();
        const end = response.end;
        response.end = function (data, encoding, callback) {
            let result = data;
            if (response.get("Content-Type").startsWith("application/json")) {
                result = JSON.parse(data.toString());
            }
            self.captureResponse(null, result);
            self.flush(function () {
                self.cleanup();
                end.call(response, data, encoding, callback);
            });
        };
        this.log(LogType.INFO, request.body, null, ["request"]);
    }
    callback() {
        return this._callback;
    }
    log(type, data, params, tags) {
        if (data instanceof Error) {
            this.logError(type, data, tags);
        }
        else if (typeof data === "string") {
            let dataString = data;
            if (params !== undefined && params !== null) {
                let allParams = [data];
                for (let param of params) {
                    allParams.push(param);
                }
                dataString = util.format.apply(this, allParams);
            }
            this._queue.push(new Log(type, dataString, null, tags));
        }
        else {
            if (data === undefined) {
                data = null;
            }
            this._queue.push(new Log(type, data, null, tags));
        }
    }
    logError(type, error, tags) {
        let message = error.name + ": " + error.message;
        if (error.code !== undefined) {
            message += " code: " + error.code;
        }
        if (error.syscall !== undefined) {
            message += " syscall: " + error.syscall;
        }
        this._queue.push(new Log(type, message, error.stack, tags));
    }
    captureResponse(error, result) {
        if (error !== undefined && error !== null) {
            this.log(LogType.ERROR, error, null, ["response"]);
        }
        else {
            this.log(LogType.INFO, result, null, ["response"]);
        }
    }
    transactionID() {
        return this._transactionID;
    }
    newTransactionID() {
        this._transactionID = uuid.v4();
    }
    cleanup() {
        process.removeListener("uncaughtException", this._uncaughtExceptionHandler);
    }
    flush(flushed) {
        if (!this._transactionID) {
            this.newTransactionID();
        }
        const logBatch = {
            source: this._source,
            transaction_id: this.transactionID(),
            logs: new Array()
        };
        for (let log of this._queue) {
            const timestamp = log.timestampAsISOString();
            const logJSON = {
                payload: log.data,
                log_type: LogType[log.type],
                timestamp: timestamp,
            };
            if (log.tags !== undefined && log.tags !== null) {
                logJSON.tags = log.tags;
            }
            if (log.stack !== undefined && log.stack !== null) {
                logJSON.stack = log.stack;
            }
            logBatch.logs.push(logJSON);
        }
        this.transmit(logBatch, flushed);
        this._queue = [];
    }
    transmit(logBatch, flushed) {
        const dataAsString = JSON.stringify(logBatch);
        const dataLength = Buffer.byteLength(dataAsString);
        const options = {
            host: logless_1.Logless.Domain,
            path: "/v1/receive",
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Content-Length": dataLength,
                "Connection": "keep-alive"
            }
        };
        const httpRequest = https.request(options);
        httpRequest.on("error", function (error) {
            console.error(error.toString());
            if (flushed !== undefined) {
                flushed();
            }
        });
        httpRequest.setNoDelay(true);
        httpRequest.end(dataAsString, null, function () {
            if (flushed !== undefined) {
                flushed();
            }
        });
    }
    usesContinuationLocalStorage() {
        return process.namespaces !== undefined &&
            require("continuation-local-storage").getNamespace("Logless") !== undefined;
    }
}
exports.LoglessContext = LoglessContext;
var LogType;
(function (LogType) {
    LogType[LogType["DEBUG"] = 0] = "DEBUG";
    LogType[LogType["ERROR"] = 1] = "ERROR";
    LogType[LogType["INFO"] = 2] = "INFO";
    LogType[LogType["WARN"] = 3] = "WARN";
})(LogType = exports.LogType || (exports.LogType = {}));
class Log {
    constructor(type, data, stack, tags) {
        this.type = type;
        this.data = data;
        this.stack = stack;
        this.tags = tags;
        this._timestamp = new Date();
    }
    timestampAsISOString() {
        return this._timestamp.toISOString();
    }
}
exports.Log = Log;
//# sourceMappingURL=logless-context.js.map