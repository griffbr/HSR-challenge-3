"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var http = require("http");
var logging_helper_1 = require("../core/logging-helper");
var module_manager_1 = require("./module-manager");
var chalk = require("chalk");
var Logger = "BST-LAMBDA";
var LambdaServer = (function () {
    function LambdaServer(file, port, verbose, functionName) {
        this.file = file;
        this.port = port;
        this.verbose = verbose;
        this.functionName = functionName;
        this.requests = [];
        this.server = null;
    }
    LambdaServer.prototype.start = function (callback) {
        var self = this;
        this.moduleManager = new module_manager_1.ModuleManager(process.cwd());
        this.moduleManager.start();
        this.server = http.createServer();
        this.server.listen(this.port);
        this.server.on("request", function (request, response) {
            self.requests.push(request);
            var requestBody = new Buffer("");
            request.on("data", function (chunk) {
                requestBody = Buffer.concat([requestBody, chunk]);
            });
            request.on("end", function () {
                var isPing = request.method === "GET" && request.url && request.url.indexOf("/localPing") !== -1;
                if (isPing) {
                    return response.end("ALIVE");
                }
                self.invoke(request, requestBody, response);
            });
        });
        this.server.on("listening", function () {
            logging_helper_1.LoggingHelper.debug(Logger, "LambdaServer started on port: " + self.server.address().port.toString());
            if (callback !== undefined && callback !== null) {
                callback();
            }
        });
    };
    LambdaServer.prototype.stop = function (onStop) {
        this.moduleManager.stop();
        var request = null;
        for (var _i = 0, _a = this.requests; _i < _a.length; _i++) {
            request = _a[_i];
            try {
                request.socket.end();
            }
            catch (e) {
            }
        }
        this.server.close(function () {
            if (onStop !== undefined && onStop !== null) {
                onStop();
            }
        });
    };
    LambdaServer.prototype.invoke = function (request, body, response) {
        var path;
        var handlerFunction;
        var context = new LambdaContext(request, body, response, this.verbose);
        var onlyUrl = request.url.split("?")[0];
        if (this.file) {
            path = this.file;
        }
        else {
            if (onlyUrl !== "/") {
                if (/(.*\..*\.)|(.*node_modules)/.test(onlyUrl)) {
                    context.fail(Error("LambdaServer input url should not contain more than '.' or node_modules.  found: " + onlyUrl));
                    return;
                }
                var splitUrl = onlyUrl.split(".");
                path = splitUrl[0];
                handlerFunction = splitUrl[1];
            }
            else {
                context.fail(Error("You should provide the lambda file or pass it in the url"));
                return;
            }
        }
        logging_helper_1.LoggingHelper.debug(Logger, "Invoking Lambda: " + path);
        var lambda = this.moduleManager.module(path);
        try {
            var bodyToString = body.toString();
            var bodyJSON = JSON.parse(bodyToString === "" ? null : bodyToString);
            if (this.verbose) {
                console.log("Request:");
                console.log(JSON.stringify(bodyJSON, null, 2));
            }
            handlerFunction = handlerFunction ? handlerFunction : this.functionName ? this.functionName : "handler";
            Promise.resolve(lambda[handlerFunction](bodyJSON, context, function (error, result) {
                context.done(error, result);
            })).then(function (result) {
                if (result) {
                    context.done(null, result);
                }
            }, function (error) { return context.done(error, null); });
        }
        catch (e) {
            console.error(chalk.red(e.toString()));
            context.fail(e);
        }
    };
    return LambdaServer;
}());
exports.LambdaServer = LambdaServer;
var LambdaContext = (function () {
    function LambdaContext(request, body, response, verbose) {
        this.request = request;
        this.body = body;
        this.response = response;
        this.verbose = verbose;
        this.awsRequestId = "N/A";
        this.callbackWaitsForEmptyEventLoop = true;
        this.functionName = "BST.LambdaServer";
        this.functionVersion = "N/A";
        this.memoryLimitInMB = -1;
        this.invokedFunctionArn = "N/A";
        this.logGroupName = "N/A";
        this.logStreamName = null;
        this.identity = null;
        this.clientContext = null;
    }
    LambdaContext.prototype.fail = function (error) {
        this.done(error, null);
    };
    LambdaContext.prototype.succeed = function (body) {
        this.done(null, body);
    };
    LambdaContext.prototype.getRemainingTimeMillis = function () {
        return -1;
    };
    LambdaContext.prototype.done = function (error, body) {
        var statusCode = 200;
        var contentType = "application/json";
        var bodyString = null;
        if (error === null) {
            bodyString = JSON.stringify(body);
            if (this.verbose) {
                console.log("Response:");
                console.log(JSON.stringify(body, null, 2));
            }
        }
        else {
            statusCode = 500;
            contentType = "text/plain";
            bodyString = "Unhandled Exception from Lambda: " + error.toString();
        }
        this.response.writeHead(statusCode, {
            "Content-Type": contentType
        });
        this.response.end(new Buffer(bodyString));
    };
    return LambdaContext;
}());
//# sourceMappingURL=lambda-server.js.map