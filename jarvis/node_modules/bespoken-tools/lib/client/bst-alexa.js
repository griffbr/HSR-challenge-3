"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const interaction_model_1 = require("../alexa/interaction-model");
const alexa_1 = require("../alexa/alexa");
const global_1 = require("../core/global");
const service_request_1 = require("../alexa/service-request");
class BSTAlexaEvents {
}
BSTAlexaEvents.AudioPlayerPlaybackFinished = "AudioPlayer.PlaybackFinished";
BSTAlexaEvents.AudioPlayerPlaybackNearlyFinished = "AudioPlayer.PlaybackNearlyFinished";
BSTAlexaEvents.AudioPlayerPlaybackStarted = "AudioPlayer.PlaybackStarted";
BSTAlexaEvents.AudioPlayerPlaybackStopped = "AudioPlayer.PlaybackStopped";
BSTAlexaEvents.Response = "response";
exports.BSTAlexaEvents = BSTAlexaEvents;
class BSTAlexa {
    constructor(skillURL, intentSchemaFile, sampleUtterancesFile, applicationID) {
        this.skillURL = skillURL;
        this.intentSchemaFile = intentSchemaFile;
        this.sampleUtterancesFile = sampleUtterancesFile;
        this.applicationID = applicationID;
        this._alexa = null;
        if (!this.intentSchemaFile) {
            this.intentSchemaFile = BSTAlexa.DefaultIntentSchemaLocation;
        }
        if (!this.sampleUtterancesFile) {
            this.sampleUtterancesFile = BSTAlexa.DefaultSampleUtterancesLocation;
        }
        this._alexa = new alexa_1.Alexa();
        if (global_1.Global.config()) {
            if (this.applicationID) {
                global_1.Global.config().updateApplicationID(this.applicationID);
            }
            else {
                this.applicationID = global_1.Global.config().applicationID();
            }
        }
    }
    start(ready) {
        let self = this;
        interaction_model_1.InteractionModel.fromFiles(this.intentSchemaFile, this.sampleUtterancesFile, function (model, error) {
            if (error !== undefined && error !== null) {
                ready(error);
            }
            else {
                self._alexa.startSession(self.skillURL, model, true, self.applicationID);
                ready();
            }
        });
    }
    context() {
        return this._alexa.context();
    }
    on(eventType, callback) {
        if (eventType.startsWith("AudioPlayer")) {
            if (!BSTAlexa.validateAudioEventType(eventType)) {
                throw Error("No event type: " + eventType + " is defined");
            }
            if (this._alexa.context().audioPlayerEnabled()) {
                this._alexa.context().audioPlayer().on(eventType, callback);
            }
        }
        else if (eventType === BSTAlexaEvents.Response) {
            this._alexa.on(alexa_1.AlexaEvent.SkillResponse, callback);
        }
        else {
            throw Error("No event type: " + eventType + " is defined");
        }
        return this;
    }
    once(eventType, callback) {
        if (eventType.startsWith("AudioPlayer")) {
            if (!BSTAlexa.validateAudioEventType(eventType)) {
                throw Error("No event type: " + eventType + " is defined");
            }
            if (this._alexa.context().audioPlayerEnabled()) {
                this._alexa.context().audioPlayer().once(eventType, callback);
            }
        }
        else if (eventType === BSTAlexaEvents.Response) {
            this._alexa.once(alexa_1.AlexaEvent.SkillResponse, callback);
        }
        else {
            throw Error("No event type: " + eventType + " is defined");
        }
        return this;
    }
    spoken(phrase, callback) {
        this._alexa.spoken(phrase, function (error, response, request) {
            if (callback !== undefined && callback !== null) {
                callback(error, response, request);
            }
        });
        return this;
    }
    intended(intentName, slots, callback) {
        this._alexa.intended(intentName, slots, function (error, response, request) {
            if (callback !== undefined && callback !== null) {
                callback(error, response, request);
            }
        });
        return this;
    }
    launched(callback) {
        this._alexa.launched(callback);
        return this;
    }
    sessionEnded(sessionEndedReason, callback) {
        const sessionEndedEnum = service_request_1.SessionEndedReason[sessionEndedReason];
        this._alexa.sessionEnded(sessionEndedEnum, null, callback);
        return this;
    }
    playbackFinished(callback) {
        if (this._alexa.context().audioPlayerEnabled()) {
            if (this._alexa.context().audioPlayer().isPlaying()) {
                this._alexa.context().audioPlayer().playbackFinished(callback);
            }
        }
        return this;
    }
    playbackNearlyFinished(callback) {
        if (this._alexa.context().audioPlayerEnabled()) {
            if (this._alexa.context().audioPlayer().isPlaying()) {
                this._alexa.context().audioPlayer().playbackNearlyFinished(callback);
            }
        }
        return this;
    }
    playbackStopped(callback) {
        if (this._alexa.context().audioPlayerEnabled()) {
            if (this._alexa.context().audioPlayer().isPlaying()) {
                this._alexa.context().audioPlayer().playbackStopped(callback);
            }
        }
        return this;
    }
    playbackOffset(offsetInMilliseconds) {
        this._alexa.context().audioPlayer().playbackOffset(offsetInMilliseconds);
        return this;
    }
    stop(onStop) {
        this._alexa.stop(onStop);
    }
    static validateAudioEventType(eventType) {
        let match = false;
        for (let e of BSTAlexa.AudioPlayerEvents) {
            if (eventType === e) {
                match = true;
                break;
            }
        }
        return match;
    }
}
BSTAlexa.AudioPlayerEvents = [BSTAlexaEvents.AudioPlayerPlaybackFinished,
    BSTAlexaEvents.AudioPlayerPlaybackNearlyFinished,
    BSTAlexaEvents.AudioPlayerPlaybackStarted,
    BSTAlexaEvents.AudioPlayerPlaybackStopped];
BSTAlexa.DefaultIntentSchemaLocation = "speechAssets/IntentSchema.json";
BSTAlexa.DefaultSampleUtterancesLocation = "speechAssets/SampleUtterances.txt";
exports.BSTAlexa = BSTAlexa;
//# sourceMappingURL=bst-alexa.js.map