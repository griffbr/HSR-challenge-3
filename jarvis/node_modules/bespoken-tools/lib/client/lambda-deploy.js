"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var os = require("os");
var path = require("path");
var async = require("async");
var logging_helper_1 = require("../core/logging-helper");
var aws = require("aws-sdk");
var exec = require("child_process").exec;
var logger = "LambdaDeploy";
var LambdaDeploy = (function () {
    function LambdaDeploy() {
        this.codeDirectory = function () {
            var epoch_time = +new Date();
            return os.tmpdir() + "/" + this.lambdaConfig.AWS_FUNCTION_NAME + "-" + epoch_time;
        };
        this.nativeZipFiles = function (codeDirectory, callback) {
            var ms_since_epoch = new Date().getTime();
            var filename = this.lambdaConfig.AWS_FUNCTION_NAME + "-" + ms_since_epoch + ".zip";
            var zipfile = path.join(os.tmpdir(), filename);
            var cmd = "zip -r " + zipfile + " .";
            exec(cmd, {
                cwd: codeDirectory,
                maxBuffer: 50 * 1024 * 1024
            }, function (err) {
                if (err !== null) {
                    return callback(err, null);
                }
                var data = fs.readFileSync(zipfile);
                callback(null, data);
            });
            logging_helper_1.LoggingHelper.verbose(logger, "Packaged zip created: " + zipfile);
        };
        this.zipFiles = function (codeDirectory, callback) {
            callback(null);
        };
    }
    LambdaDeploy.create = function (lambdaFolder, lambdaConfig) {
        var instance = new LambdaDeploy();
        instance.lambdaConfig = lambdaConfig;
        instance.lambdaFolder = lambdaFolder;
        return instance;
    };
    LambdaDeploy.prototype.deploy = function (callback) {
        var self = this;
        var regions = this.lambdaConfig.AWS_REGION.split(",");
        this.archive(function (err, buffer) {
            if (err) {
                throw err;
            }
            logging_helper_1.LoggingHelper.verbose(logger, "Reading zip file to memory");
            var params = self.params(buffer);
            async.map(regions, cb, function (err, results) {
                if (err) {
                    throw err;
                }
                else {
                    console.log("Zip file(s) done uploading.");
                    console.log("Enter this ARN(s) on the Configuration tab of your skill:");
                    results.map(function (result) {
                        console.log();
                        console.log("\t" + result.FunctionArn);
                        console.log();
                    });
                    if (callback) {
                        callback(null);
                    }
                }
            });
            function cb(region, callback) {
                logging_helper_1.LoggingHelper.verbose(logger, "Uploading zip file to lambda " + region + " with parameters:");
                self.logParams(params);
                var aws_security = {
                    accessKeyId: self.lambdaConfig.AWS_ACCESS_KEY_ID,
                    secretAccessKey: self.lambdaConfig.AWS_SECRET_ACCESS_KEY,
                    region: region
                };
                aws.config.update(aws_security);
                var lambda = new aws.Lambda({
                    apiVersion: "2015-03-31"
                });
                return lambda.getFunction({
                    "FunctionName": params.FunctionName
                }, function (err) {
                    if (err) {
                        return self.uploadNew(lambda, params, callback);
                    }
                    return self.uploadExisting(lambda, params, callback);
                });
            }
        });
    };
    ;
    LambdaDeploy.prototype.logParams = function (params) {
        var buff = params.Code.ZipFile;
        params.Code.ZipFile = "<" + buff.length + " bytes>";
        logging_helper_1.LoggingHelper.verbose(logger, JSON.stringify(params, null, 2));
        params.Code.ZipFile = buff;
    };
    LambdaDeploy.prototype.uploadExisting = function (lambda, params, callback) {
        return lambda.updateFunctionCode({
            "FunctionName": params.FunctionName,
            "ZipFile": params.Code.ZipFile,
            "Publish": params.publish
        }, function (err, data) {
            if (err) {
                return callback(err, data);
            }
            return lambda.updateFunctionConfiguration({
                "FunctionName": params.FunctionName,
                "Description": params.Description,
                "Handler": params.Handler,
                "MemorySize": params.MemorySize,
                "Role": params.Role,
                "Timeout": params.Timeout,
                "VpcConfig": params.VpcConfig
            }, function (err, data) {
                logging_helper_1.LoggingHelper.verbose(logger, "Lambda function was updated: " + params.FunctionName);
                return callback(err, data);
            });
        });
    };
    LambdaDeploy.prototype.uploadNew = function (lambda, params, callback) {
        return lambda.createFunction(params, function (err, functionData) {
            if (!err) {
                logging_helper_1.LoggingHelper.verbose(logger, "Lambda function was created: " + params.FunctionName);
            }
            else {
                return callback(err, functionData);
            }
            console.log("Waiting for AWS to propagate the changes");
            setTimeout(function () {
                return lambda.addPermission({
                    "FunctionName": params.FunctionName,
                    "Action": "lambda:InvokeFunction",
                    "Principal": "alexa-appkit.amazon.com",
                    "StatementId": new Date().getTime() + ""
                }, function (err, data) {
                    if (!err) {
                        logging_helper_1.LoggingHelper.verbose(logger, "Alexa trigger was added to the function");
                    }
                    return callback(err, functionData);
                });
            }, 3000);
        });
    };
    LambdaDeploy.prototype.params = function (buffer) {
        var params = {
            FunctionName: this.lambdaConfig.AWS_FUNCTION_NAME,
            Code: {
                ZipFile: buffer
            },
            Handler: this.lambdaConfig.AWS_HANDLER,
            Role: this.lambdaConfig.AWS_ROLE_ARN,
            Runtime: this.lambdaConfig.AWS_RUNTIME,
            Description: this.lambdaConfig.AWS_DESCRIPTION,
            MemorySize: this.lambdaConfig.AWS_MEMORY_SIZE,
            Timeout: this.lambdaConfig.AWS_TIMEOUT,
            Publish: this.lambdaConfig.AWS_PUBLISH,
            VpcConfig: {}
        };
        if (this.lambdaConfig.AWS_FUNCTION_VERSION) {
            params.FunctionName += ("-" + this.lambdaConfig.AWS_FUNCTION_VERSION);
        }
        if (this.lambdaConfig.AWS_VPC_SUBNETS && this.lambdaConfig.AWS_VPC_SECURITY_GROUPS) {
            params.VpcConfig = {
                "SubnetIds": this.lambdaConfig.AWS_VPC_SUBNETS.split(","),
                "SecurityGroupIds": this.lambdaConfig.AWS_VPC_SECURITY_GROUPS.split(",")
            };
        }
        return params;
    };
    ;
    LambdaDeploy.prototype.archive = function (callback) {
        return this.lambdaConfig.PREBUILT_DIRECTORY
            ? this.archivePrebuilt(callback) : this.buildAndArchive(callback);
    };
    LambdaDeploy.prototype.buildAndArchive = function (callback) {
        var self = this;
        var codeDirectory = this.codeDirectory();
        this.cleanDirectory(codeDirectory, function (err) {
            if (err) {
                return callback(err);
            }
            logging_helper_1.LoggingHelper.verbose(logger, "Moving files to temporary directory");
            self.copyFiles(self.lambdaFolder, codeDirectory, true, function (err) {
                if (err) {
                    return callback(err);
                }
                logging_helper_1.LoggingHelper.verbose(logger, "Running npm install --production");
                self.npmInstall(codeDirectory, function (err) {
                    if (err) {
                        return callback(err);
                    }
                    self.postInstallScript(codeDirectory, function (err) {
                        if (err) {
                            return callback(err);
                        }
                        logging_helper_1.LoggingHelper.verbose(logger, "Zipping deployment package");
                        if (process.platform !== "win32") {
                            self.nativeZipFiles(codeDirectory, callback);
                        }
                        else {
                            self.zipFiles(codeDirectory, callback);
                        }
                    });
                });
            });
        });
    };
    LambdaDeploy.prototype.postInstallScript = function (codeDirectory, callback) {
        callback(null);
    };
    LambdaDeploy.prototype.npmInstall = function (codeDirectory, callback) {
        exec("npm -s install --production --prefix " + codeDirectory, function (err) {
            if (err) {
                return callback(err);
            }
            return callback(null);
        });
    };
    LambdaDeploy.prototype.archivePrebuilt = function (callback) {
        callback(null);
    };
    LambdaDeploy.prototype.copyFiles = function (src, dest, excludeNodeModules, callback) {
        var excludes = [".git*", "*.swp", ".editorconfig", "deploy.env", "*.log", "build/", ".DS_Store"];
        var excludeGlobs = [];
        if (this.lambdaConfig.EXCLUDE_GLOBS) {
            excludeGlobs = this.lambdaConfig.EXCLUDE_GLOBS.split(" ");
        }
        var excludeArgs = excludeGlobs
            .concat(excludes)
            .concat(excludeNodeModules ? ["node_modules"] : [])
            .map(function (exclude) {
            return "--exclude=" + exclude;
        }).join(" ");
        exec("mkdir -p " + dest, function (err) {
            if (err) {
                return callback(err);
            }
            var cmd = "rsync -rL " + excludeArgs + " " + src.trim() + "/ " + dest;
            exec(cmd, function (err, stdout, stderr) {
                if (err) {
                    return callback(err);
                }
                return callback(null);
            });
        });
    };
    LambdaDeploy.prototype.cleanDirectory = function (codeDirectory, callback) {
        exec("rm -rf " + codeDirectory, function (err) {
            if (err) {
                throw err;
            }
            fs.mkdir(codeDirectory, function (err) {
                if (err) {
                    throw err;
                }
                return callback(null);
            });
        });
    };
    ;
    return LambdaDeploy;
}());
exports.LambdaDeploy = LambdaDeploy;
//# sourceMappingURL=lambda-deploy.js.map