"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var ModuleInvoker = (function () {
    function ModuleInvoker() {
    }
    ModuleInvoker.invokeHandler = function (handler, event) {
        var functionName = "handler";
        var fileName = handler;
        if (!handler.endsWith(".js")) {
            var functionSeparatorIndex = handler.lastIndexOf(".");
            functionName = handler.substr(functionSeparatorIndex + 1);
            fileName = handler.substr(0, functionSeparatorIndex);
            fileName += ".js";
        }
        var fullPath = path.join(process.cwd(), fileName);
        var handlerModule = require(fullPath);
        return ModuleInvoker.invokeFunction(handlerModule[functionName], event);
    };
    ModuleInvoker.invokeFunction = function (lambdaFunction, event) {
        return new Promise(function (resolve, reject) {
            var callback = function (error, result) {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            var context = new LambdaContext(callback);
            var promise = lambdaFunction(event, context, callback);
            if (promise) {
                promise.then(function (result) {
                    context.done(null, result);
                }).catch(function (error) {
                    context.done(error, null);
                });
            }
        });
    };
    return ModuleInvoker;
}());
exports.ModuleInvoker = ModuleInvoker;
var LambdaContext = (function () {
    function LambdaContext(callback) {
        this.callback = callback;
        this.awsRequestId = "N/A";
        this.callbackWaitsForEmptyEventLoop = true;
        this.functionName = "BST.LambdaServer";
        this.functionVersion = "N/A";
        this.memoryLimitInMB = -1;
        this.invokedFunctionArn = "N/A";
        this.logGroupName = "N/A";
        this.logStreamName = null;
        this.identity = null;
        this.clientContext = null;
    }
    LambdaContext.prototype.fail = function (error) {
        this.done(error, null);
    };
    LambdaContext.prototype.succeed = function (body) {
        this.done(null, body);
    };
    LambdaContext.prototype.getRemainingTimeMillis = function () {
        return -1;
    };
    LambdaContext.prototype.done = function (error, body) {
        var statusCode = 200;
        var contentType = "application/json";
        var bodyString = null;
        if (error === null) {
            bodyString = JSON.stringify(body);
        }
        else {
            statusCode = 500;
            contentType = "text/plain";
            bodyString = "Unhandled Exception from Lambda: " + error.toString();
        }
        this.callback(error, body);
    };
    return LambdaContext;
}());
//# sourceMappingURL=ModuleInvoker.js.map