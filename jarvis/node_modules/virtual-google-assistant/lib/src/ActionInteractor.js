"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ActionRequest_1 = require("./ActionRequest");
const virtual_core_1 = require("virtual-core");
class ActionInteractor {
    constructor(interactionModel, locale) {
        this.interactionModel = interactionModel;
        this.locale = locale;
        this.requestFilters = [];
        this.context = [];
    }
    spoken(utteranceString) {
        let utterance = new virtual_core_1.Utterance(this.interactionModel, utteranceString);
        if (!utterance.matched()) {
            const defaultPhrase = this.interactionModel.sampleUtterances.defaultUtterance();
            utterance = new virtual_core_1.Utterance(this.interactionModel, defaultPhrase.phrase);
            console.warn("No intentName matches utterance: " + utteranceString
                + ". Using fallback utterance: " + defaultPhrase.phrase);
        }
        return this.callSkillWithIntent(utterance.intent(), utterance.toJSON());
    }
    resetContext() {
        this.context = [];
    }
    launched() {
        const ActionRequestVersion = this.interactionModel.dialogFlowApiVersion === "v1" ? ActionRequest_1.ActionRequestV1 : ActionRequest_1.ActionRequestV2;
        const serviceRequest = new ActionRequestVersion(this.interactionModel, this.locale);
        this.resetContext();
        return this.callSkill(serviceRequest.launchRequest());
    }
    intended(intentName, slots) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.callSkillWithIntent(intentName, slots);
        });
    }
    addFilter(requestFilter) {
        this.requestFilters.push(requestFilter);
    }
    resetFilters() {
        this.requestFilters = [];
    }
    callSkill(serviceRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestJSON = serviceRequest.toJSON();
            if (this.context) {
                if (requestJSON.queryResult) {
                    requestJSON.queryResult.outputContexts = this.context;
                }
                else {
                    requestJSON.result.contexts = this.context;
                }
            }
            if (this.requestFilters.length) {
                this.requestFilters.forEach((requestFilter) => {
                    requestFilter(requestJSON);
                });
            }
            const response = yield this.invoke(requestJSON);
            this.context = response.contextOut || response.outputContexts;
            return response;
        });
    }
    callSkillWithIntent(intentName, slots) {
        return __awaiter(this, void 0, void 0, function* () {
            const ActionRequestVersion = this.interactionModel.dialogFlowApiVersion === "v1" ? ActionRequest_1.ActionRequestV1 : ActionRequest_1.ActionRequestV2;
            const serviceRequest = new ActionRequestVersion(this.interactionModel, this.locale).intentRequest(intentName);
            if (slots !== undefined && slots !== null) {
                for (const slotName of Object.keys(slots)) {
                    serviceRequest.withSlot(slotName, slots[slotName]);
                }
            }
            return this.callSkill(serviceRequest);
        });
    }
}
exports.ActionInteractor = ActionInteractor;
//# sourceMappingURL=ActionInteractor.js.map