var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require("lodash");
var childProcess = require("child_process");
var debug = require("./Debug");
var FrameworkError = require("./FrameworkError");
var fs = require("fs");
var HTTP = require("./HTTP");
var os = require("os");
var path = require("path");
var url = require("url");
var Util = require("./Util");

module.exports = function () {
    function SMAPI(token, skillId, locale, askConfigured = false) {
        _classCallCheck(this, SMAPI);

        this.skillId = skillId;
        this.token = token;
        this.locale = locale ? locale : "en-US";
        this.askConfigured = askConfigured;
    }

    // Gets the SMAPI access token from the ASK config file


    _createClass(SMAPI, [{
        key: "headers",


        // Headers to be passed for any HTTP calls
        value: function headers() {
            return {
                Accept: "application/json",
                Authorization: this.token,
                "Content-Type": "application/json"
            };
        }

        // Refreshes the ASK token via calling the ASK CLI with a simple command
        // Bit of a hack, but it works

    }, {
        key: "refreshFromCLI",
        value: function refreshFromCLI() {
            var result = childProcess.spawnSync("ask", ["api", "get-skill", "-s", this.skillId], { shell: true });
            /* eslint-disable-next-line no-console */
            console.log("REFRESHING TOKEN FROM CLI. STATUS: " + result.status);
            return result.status === 0;
        }

        // Calls the simulate operations and waits for it to complete with the named command
        // If newSession is true, forces a new session

    }, {
        key: "simulate",
        value: (() => {
            var _ref = _asyncToGenerator(function* (command, newSession) {
                var simulation = new Simulation(this);
                debug("SMAPI COMMAND: " + command);
                var postResult = yield simulation.post(command, newSession);
                debug("RESULT: " + JSON.stringify(postResult, null, 2));
                if (postResult.message || postResult.message === null) {
                    if ((postResult.message === null || postResult.message.includes("Token is invalid")) && this.askConfigured) {
                        if (this.refreshFromCLI()) {
                            this.token = SMAPI.fetchAccessTokenFromConfig();
                            return this.simulate(command, newSession);
                        } else {
                            throw new FrameworkError("Token is invalid and unable to refresh via ASK CLI");
                        }
                    } else {
                        throw new FrameworkError(postResult.message);
                    }
                }

                var getResult = void 0;
                while (!getResult || getResult.status === "IN_PROGRESS") {
                    yield Util.sleep(1000);
                    getResult = yield simulation.get(postResult.id);
                    debug("SMAPI RESULT: " + JSON.stringify(getResult, null, 2));

                    if (getResult.status !== "IN_PROGRESS") {
                        debug("SMAPI RESULT: " + JSON.stringify(getResult, null, 2));

                        if (getResult.message) {
                            throw new FrameworkError(getResult.message);
                        }
                        return getResult;
                    }
                }
            });

            function simulate(_x, _x2) {
                return _ref.apply(this, arguments);
            }

            return simulate;
        })()
    }], [{
        key: "fetchAccessTokenFromConfig",
        value: function fetchAccessTokenFromConfig() {
            // Retrieves the access token - first tries getting it from the ASK CLI
            var cliConfigFile = path.join(os.homedir(), ".ask/cli_config");
            var accessToken = void 0;
            if (fs.existsSync(cliConfigFile)) {
                var cliConfigString = fs.readFileSync(cliConfigFile);
                var cliConfig = JSON.parse(cliConfigString);
                accessToken = cliConfig.profiles.default.token.access_token;
            } else {
                return undefined;
            }
            return accessToken;
        }

        // Gets a SMAPI token from the Virtual Device server - this is a pass-through to the Amazon authentication

    }, {
        key: "fetchAccessTokenFromServer",
        value: (() => {
            var _ref2 = _asyncToGenerator(function* (virtualDeviceToken) {
                var urlString = process.env.VIRTUAL_DEVICE_BASE_URL ? process.env.VIRTUAL_DEVICE_BASE_URL : "https://virtual-device.bespoken.io";
                var urlParts = url.parse(urlString);

                var path = "/access_token?user_id=" + virtualDeviceToken;

                var getOptions = {
                    host: urlParts.hostname,
                    method: "GET",
                    path: path,
                    port: urlParts.port,
                    protocol: urlParts.protocol
                };

                var response = yield HTTP.get(getOptions);
                if (response.message.statusCode !== 200) {
                    throw new FrameworkError("Invalid virtual device token: " + virtualDeviceToken + " Raw Error: " + response.body.trim());
                }
                debug("SMAPI TOKEN: " + response.json.token);
                return response.json.token;
            });

            function fetchAccessTokenFromServer(_x3) {
                return _ref2.apply(this, arguments);
            }

            return fetchAccessTokenFromServer;
        })()

        // Uses the project ask configuration to get the skill id, if possible

    }, {
        key: "fetchSkillIdFromConfig",
        value: function fetchSkillIdFromConfig() {
            var projectConfigFile = path.join(process.cwd(), ".ask/config");
            var skillId = void 0;
            if (fs.existsSync(projectConfigFile)) {
                var projectJSONString = fs.readFileSync(projectConfigFile);
                var projectJSON = JSON.parse(projectJSONString);
                skillId = _.get(projectJSON, "deploy_settings.default.skill_id");
            }
            return skillId;
        }
    }]);

    return SMAPI;
}();

// Implementation of underlying HTTP calls for the simulations endpoint

var Simulation = function () {
    function Simulation(smapi) {
        _classCallCheck(this, Simulation);

        this.smapi = smapi;
    }

    _createClass(Simulation, [{
        key: "get",
        value: (() => {
            var _ref3 = _asyncToGenerator(function* (simulationId) {
                var path = "/v1/skills/" + this.smapi.skillId + "/simulations/" + simulationId;

                var getOptions = {
                    headers: this.smapi.headers(),
                    host: "api.amazonalexa.com",
                    method: "GET",
                    path: path,
                    port: "443"
                };

                var response = yield HTTP.get(getOptions);
                debug("SIMULATION GET MESSAGE: " + response.message.statusCode);
                debug("SIMULATION GET BODY: " + response.body);
                return response.json;
            });

            function get(_x4) {
                return _ref3.apply(this, arguments);
            }

            return get;
        })()
    }, {
        key: "post",
        value: (() => {
            var _ref4 = _asyncToGenerator(function* (command, newSession = false) {
                var mode = newSession ? "FORCE_NEW_SESSION" : "DEFAULT";

                var body = {
                    device: {
                        locale: this.smapi.locale
                    },
                    input: {
                        content: command
                    },
                    session: {
                        mode: mode
                    }
                };

                var path = "/v1/skills/" + this.smapi.skillId + "/simulations";
                var postOptions = {
                    headers: this.smapi.headers(),
                    host: "api.amazonalexa.com",
                    method: "POST",
                    path: path,
                    port: "443"
                };

                var response = yield HTTP.post(postOptions, body);
                debug("SIMULATION POST MESSAGE: " + response.message.statusCode);
                debug("SIMULATION POST BODY: " + response.body);
                return response.json;
            });

            function post(_x5) {
                return _ref4.apply(this, arguments);
            }

            return post;
        })()
    }]);

    return Simulation;
}();