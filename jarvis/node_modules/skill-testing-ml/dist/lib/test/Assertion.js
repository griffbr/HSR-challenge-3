var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var jsonpath = require("jsonpath");
var ParserError = require("./ParserError");
var Util = require("../util/Util");

var OPERATORS = ["==", "=~", "!=", ">", ">=", "<", "<="];
var NUMERIC_OPERATORS = [">", ">=", "<", "<="];

module.exports = function () {
    function Assertions(interaction, path, operator, value) {
        _classCallCheck(this, Assertions);

        this._interaction = interaction;
        this._path = path;
        this._operator = operator;
        this._value = value;
        this._goto = undefined;
        this.parse();
    }

    _createClass(Assertions, [{
        key: "parse",
        value: function parse() {
            if (this.exit) {
                return;
            }

            // Looks for a goto in the value statement
            if (Util.isString(this._value) && this._value.includes(" goto ")) {
                var gotoRegex = /(.*) goto (.*)/i;
                var matchArray = this._value.match(gotoRegex);
                if (matchArray.length === 2) {
                    throw ParserError.interactionError(this.interaction, "Invalid goto - does not have label: " + this._value, this.lineNumber);
                } else if (matchArray.length === 3) {
                    this._value = matchArray[1];
                    this._goto = matchArray[2];
                }
            }
        }
    }, {
        key: "validate",
        value: function validate() {
            var path = jsonpath.parse(this.path);
            if (!path) {
                throw ParserError.interactionError(this.interaction, "Invalid JSON path: " + this.path, this.lineNumber);
            }

            if (!OPERATORS.includes(this.operator)) {
                throw ParserError.interactionError(this.interaction, "Invalid operator: " + this.operator, this.lineNumber);
            }

            // Check to make sure the expected value is a number if this is a numeric operator
            if (NUMERIC_OPERATORS.includes(this.operator)) {
                if (isNaN(this.value)) {
                    throw ParserError.interactionError(this.interaction, "Invalid expected value - must be numeric: " + this.value, this.lineNumber);
                }
            }
        }
    }, {
        key: "evaluate",
        value: function evaluate(response) {
            var testSuite = response.interaction && response.interaction.test && response.interaction.test.testSuite;
            var json = response.json;
            var jsonValue = this.valueAtPath(json);

            if (this.operator === "==" || this.operator === "=~") {
                if (this.value === undefined) {
                    return jsonValue === undefined;
                }

                var match = false;
                var ignoreCase = response.ignoreCase(this.path);
                if (jsonValue !== undefined) {
                    if (Array.isArray(this.value)) {
                        for (var value of this.value) {
                            var localizedValue = testSuite && testSuite.getLocalizedValue(value) || value;
                            match = this.evaluateRegexOrString(this.operator, localizedValue, jsonValue, ignoreCase);
                            // Once matched, do not need to process further
                            if (match) {
                                break;
                            }
                        }
                    } else {
                        var _localizedValue = testSuite && testSuite.getLocalizedValue(this.value) || this.value;
                        match = this.evaluateRegexOrString(this.operator, _localizedValue, jsonValue, ignoreCase);
                    }
                }
                return match;
            } else if (NUMERIC_OPERATORS.includes(this.operator)) {
                if (isNaN(jsonValue)) {
                    return false;
                }

                var expectedValue = parseInt(this.value, 10);
                var actualValue = parseInt(jsonValue, 10);

                if (this.operator === ">") {
                    return actualValue > expectedValue;
                } else if (this.operator === ">=") {
                    return actualValue >= expectedValue;
                } else if (this.operator === "<") {
                    return actualValue < expectedValue;
                } else if (this.operator === "<=") {
                    return actualValue <= expectedValue;
                }
            } else if (this.operator === "!=") {
                if (this.value === undefined) {
                    return jsonValue !== undefined;
                }
                return !jsonValue || !jsonValue.includes(this.value);
            } else {
                throw "Operator not implemented yet: " + this.operator;
            }
        }
    }, {
        key: "evaluateRegexOrString",
        value: function evaluateRegexOrString(operator, expectedValue, actualValue, ignoreCase) {
            // If the operator is the regex operator, or the value starts with /, we treat it as a regex
            if (this.isRegex(expectedValue)) {
                return this.evaluateRegex(expectedValue, actualValue, ignoreCase);
            } else {
                return this.evaluateString(expectedValue, actualValue, ignoreCase);
            }
        }
    }, {
        key: "evaluateString",
        value: function evaluateString(expectedValue, actualValue, ignoreCase) {
            // If the values are not strings, convert to a string for ease of comparison
            if (!Util.isString(expectedValue)) {
                expectedValue += "";
            }

            if (!Util.isString(actualValue)) {
                actualValue += "";
            }

            // We allow for a wild-card *
            var regex = expectedValue.trim().split("*").join(".*");
            // Escape special values that we do NOT want to treat as a wild-card
            regex = regex.split("+").join("\\+");
            regex = regex.split("^").join("\\^");
            regex = regex.split("$").join("\\$");
            regex = regex.split("?").join("\\?");

            var options = "";
            if (ignoreCase) {
                options = "i";
            }
            return new RegExp(regex, options).test(actualValue);
        }
    }, {
        key: "evaluateRegex",
        value: function evaluateRegex(expectedValue, actualValue, ignoreCase) {
            var regexString = expectedValue;
            var options = "";
            if (regexString.startsWith("/")) {
                regexString = regexString.substr(1);
                // Now get the last /, and treat the part after as options
                var endIndex = regexString.lastIndexOf("/");
                if (endIndex + 1 < regexString.length) {
                    options = regexString.substr(endIndex + 1);
                }
                regexString = regexString.substr(0, endIndex);
            }
            if (ignoreCase && options.indexOf("i") == -1) {
                options += "i";
            }
            var regex = new RegExp(regexString, options);
            return regex.test(actualValue);
        }
    }, {
        key: "isRegex",
        value: function isRegex(expectedValue) {
            return this.operator === "=~" || Util.isString(expectedValue) && expectedValue.startsWith("/");
        }
    }, {
        key: "valueAtPath",
        value: function valueAtPath(json) {
            return json ? jsonpath.value(json, this.path) : undefined;
        }
    }, {
        key: "toString",
        value: function toString(json, errorOnResponse) {
            if (errorOnResponse) {
                return errorOnResponse;
            }
            var testSuite = this.interaction && this.interaction.test && this.interaction.test.testSuite;
            var jsonValue = this.valueAtPath(json);
            var localizedValue = testSuite && testSuite.getLocalizedValue(this.value) || this.value;
            var expectedValueString = "\t" + localizedValue + "\n";
            var operator = this.operator;
            if (Array.isArray(this.value)) {
                operator = "be one of:";
                expectedValueString = "";
                for (var value of this.value) {
                    expectedValueString += "\t" + value + "\n";
                }
            } else if (NUMERIC_OPERATORS.includes(this.operator)) {
                operator = "be " + this.operator;
            }

            var message = "Expected value at [" + this.path + "] to " + operator + "\n" + expectedValueString + "Received:\n" + "\t" + jsonValue + "\n";

            // If we have a line number, show it
            if (this.lineNumber) {
                message += "at " + this.interaction.test.testSuite.fileName + ":" + this.lineNumber + ":0";
            }
            return message;
        }
    }, {
        key: "exit",
        get: function () {
            return this.path === "exit";
        }
    }, {
        key: "goto",
        get: function () {
            return Util.cleanString(this._goto);
        }
    }, {
        key: "interaction",
        get: function () {
            return this._interaction;
        }
    }, {
        key: "lineNumber",
        get: function () {
            return this._lineNumber;
        },
        set: function (number) {
            this._lineNumber = number;
        }
    }, {
        key: "path",
        get: function () {
            return Util.cleanString(this._path);
        }
    }, {
        key: "operator",
        get: function () {
            return Util.cleanString(this._operator);
        }
    }, {
        key: "value",
        get: function () {
            return Util.cleanValue(this._value);
        }
    }]);

    return Assertions;
}();