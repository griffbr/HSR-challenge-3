var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Util = require("../util/Util");
var REQUEST_TYPES = ["Display.ElementSelected", "LaunchRequest", "SessionEndedRequest"];

module.exports = function () {
    function TestInteraction(test, utterance) {
        _classCallCheck(this, TestInteraction);

        this._test = test;
        this._utterance = utterance;
        this._requestExpressions = [];
        this._assertions = [];
    }

    _createClass(TestInteraction, [{
        key: "applyExpressions",
        value: function applyExpressions(request) {
            for (var expression of this.expressions) {
                expression.apply(request);
            }
        }
    }, {
        key: "toDTO",
        value: function toDTO() {
            return {
                assertions: this.assertions.map(assertion => assertion.toString()),
                expressions: this.expressions,
                intent: this.intent,
                lineNumber: this.lineNumber,
                requestType: this.requestType,
                testDescription: Util.cleanString(this.test.description),
                utterance: this.utterance
            };
        }
    }, {
        key: "assertions",
        get: function () {
            return this._assertions;
        }
    }, {
        key: "expressions",
        get: function () {
            return this._requestExpressions;
        }
    }, {
        key: "hasGoto",
        get: function () {
            return this.assertions.find(assertion => assertion.goto !== undefined);
        }
    }, {
        key: "intent",
        get: function () {
            return this._intent;
        },
        set: function (intent) {
            this._intent = intent;
        }
    }, {
        key: "lineNumber",
        get: function () {
            return this._lineNumber;
        },
        set: function (lineNumber) {
            this._lineNumber = lineNumber;
        }
    }, {
        key: "requestType",
        get: function () {
            if (REQUEST_TYPES.includes(this._utterance)) {
                return this._utterance;
            }

            return undefined;
        }
    }, {
        key: "slots",
        get: function () {
            return this._slots;
        },
        set: function (slots) {
            this._slots = slots;
        }
    }, {
        key: "test",
        get: function () {
            return this._test;
        }
    }, {
        key: "utterance",
        get: function () {
            return this._utterance + "";
        },
        set: function (utterance) {
            this._utterance = utterance;
        }
    }, {
        key: "relativeIndex",
        get: function () {
            return this._relativeIndex;
        },
        set: function (index) {
            this._relativeIndex = index;
        }
    }, {
        key: "localizedSlots",
        get: function () {
            var slots = this._slots;
            var testSuite = this.test.testSuite;
            if (slots && testSuite) {
                return Object.keys(slots).reduce((accumulator, key) => {
                    accumulator[key] = testSuite.getLocalizedValue(slots[key]) || slots[key];
                    return accumulator;
                }, {});
            }
            return slots;
        }
    }, {
        key: "label",
        get: function () {
            return this._label;
        },
        set: function (label) {
            this._label = label;
        }
    }]);

    return TestInteraction;
}();