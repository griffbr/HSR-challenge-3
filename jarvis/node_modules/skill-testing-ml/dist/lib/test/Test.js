var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ParserError = require("./ParserError");
var Util = require("../util/Util");

module.exports = function () {
    function Test(suite, metadata, interactions) {
        _classCallCheck(this, Test);

        this._testSuite = suite;
        this._description = undefined;
        if (metadata) {
            if (Util.isString(metadata)) {
                this._description = metadata;
            } else {
                this._metadata = metadata;
                this._description = metadata.description;
            }
        }
        this._interactions = interactions;
        this._skip = false;
        this._only = false;
    }

    _createClass(Test, [{
        key: "validate",


        // Make sure all any goto statements work
        value: function validate() {
            for (var interaction of this.interactions) {
                for (var assertion of interaction.assertions) {
                    if (assertion.goto) {
                        var matched = false;
                        for (var i2 of this.interactions) {
                            if (i2.utterance === assertion.goto || i2.label == assertion.goto) {
                                matched = true;
                                break;
                            }
                        }

                        if (!matched) {
                            throw ParserError.error(this.testSuite.fileName, "No match for goto: " + assertion.goto, assertion.lineNumber);
                        }
                    }
                }
            }
            return true;
        }
    }, {
        key: "toDTO",
        value: function toDTO() {
            return {
                description: this.description,
                interactions: this.interactions.map(interaction => interaction.toDTO())
            };
        }
    }, {
        key: "description",
        get: function () {
            return this._description;
        }
    }, {
        key: "hasGoto",
        get: function () {
            return this.interactions.find(interaction => interaction.hasGoto);
        }
    }, {
        key: "interactions",
        get: function () {
            return this._interactions;
        }
    }, {
        key: "only",
        get: function () {
            return this._only;
        },
        set: function (only) {
            this._only = only;
        }
    }, {
        key: "skip",
        get: function () {
            return this._skip;
        },
        set: function (skip) {
            this._skip = skip;
        }
    }, {
        key: "testSuite",
        get: function () {
            return this._testSuite;
        }
    }]);

    return Test;
}();