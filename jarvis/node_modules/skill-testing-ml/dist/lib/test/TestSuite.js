var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Configuration = require("../runner/Configuration");
var path = require("path");
var Util = require("../util/Util");

module.exports = function () {
    function TestSuite(fileName, configuration, tests, localizedValues) {
        _classCallCheck(this, TestSuite);

        this._configuration = configuration;
        this._fileName = fileName;
        this._tests = tests;
        this._localizedValues = localizedValues;
    }

    _createClass(TestSuite, [{
        key: "resolvePath",
        value: function resolvePath(pathToResolve) {
            var configurationPath = Configuration.instance().value("configurationPath", this.configuration) || "";
            var configDirectory = path.dirname(configurationPath);
            var relativePath = path.relative(process.cwd(), configDirectory);
            return path.join(relativePath, pathToResolve);
        }
    }, {
        key: "getLocalizedValue",
        value: function getLocalizedValue(key) {
            if (!this._localizedValues || !this.locale) return undefined;
            var localizedValue = this._localizedValues[this.locale] && this._localizedValues[this.locale][key];
            if (localizedValue) return localizedValue;

            var language = this.locale.split("-")[0];
            localizedValue = this._localizedValues[language] && this._localizedValues[language][key];
            if (localizedValue) return localizedValue;

            return undefined;
        }
    }, {
        key: "filterObject",
        value: function filterObject() {
            var filterModule = this.filter;
            if (typeof this.filter === "string") {
                var filterObject = void 0;
                if (filterModule) {
                    filterModule = path.join(process.cwd(), filterModule);
                    try {
                        filterObject = require(filterModule);
                    } catch (e) {
                        // eslint-disable-next-line no-console
                        console.error("Filter specified - but filter module not found at: " + filterModule);
                    }
                }
                return filterObject;
            } else {
                return this.filter;
            }
        }
    }, {
        key: "getTagsFromString",
        value: function getTagsFromString(tagsAsString) {
            if (!Util.isString(tagsAsString)) {
                return [];
            }
            return tagsAsString.split(",").map(tag => tag.trim());
        }

        // Process the include and exclude flags and turn them to skip's and only's

    }, {
        key: "processIncludedAndExcludedTags",
        value: function processIncludedAndExcludedTags() {
            var includeRaw = this.include;
            var excludeRaw = this.exclude;

            var include = typeof includeRaw === "object" ? includeRaw : this.getTagsFromString(includeRaw);
            var exclude = typeof excludeRaw === "object" ? excludeRaw : this.getTagsFromString(excludeRaw);

            this.tests = this.tests.map(test => {
                if (!test.tags || test.tags.length === 0) {
                    if (include.length > 0) {
                        test.skip = true;
                    }

                    if (exclude.length > 0) {
                        test.only = true;
                    }
                    return test;
                }

                var isTheTestIncluded = test.tags.some(tag => include.includes(tag));
                var isTheTestExcluded = test.tags.some(tag => exclude.includes(tag));

                if (isTheTestExcluded) {
                    test.skip = true;
                }

                if (isTheTestIncluded) {
                    test.only = true;
                }

                return test;
            });
        }

        // Process the skip and only flags

    }, {
        key: "processOnlyFlag",
        value: function processOnlyFlag() {
            var hasOnly = this.tests.find(test => test.only);
            if (!hasOnly) {
                return;
            }

            // If there are only tests, flag everything that is not as skipped
            for (var test of this.tests) {
                if (!test.only) {
                    test.skip = true;
                }
            }
        }
    }, {
        key: "loadLocalizedValues",
        value: (() => {
            var _ref = _asyncToGenerator(function* () {
                var tries = 1;
                var files = [];
                var localesPath = `${this.directory}`;
                while (tries < 3 && files.length === 0) {
                    files = yield Util.readFiles(`${localesPath}/locales/`);
                    tries++;
                    localesPath = path.join(localesPath, "..");
                }
                // Files is an array of objects {filename, content}
                // reduce method will iterate the array and return an object
                // where the keys will be the file name without extension
                // and the value will be a key value object with the localization values
                this._localizedValues = files.reduce(function (accumulator, item) {
                    if (!item) return accumulator;

                    var language = path.basename(item.filename, ".yml");
                    accumulator[language] = item.content.split("\n").reduce(function (accumulatorC, itemC) {
                        if (!itemC) return accumulatorC;
                        var [key, value] = itemC.split(":");
                        if (key && value) {
                            accumulatorC[key] = value.trim();
                        }
                        return accumulatorC;
                    }, {});
                    return accumulator;
                }, {});
            });

            function loadLocalizedValues() {
                return _ref.apply(this, arguments);
            }

            return loadLocalizedValues;
        })()
    }, {
        key: "dialogFlowDirectory",
        get: function () {
            return Configuration.instance().value("dialogFlowDirectory", this.configuration);
        }
    }, {
        key: "expressModule",
        get: function () {
            return Configuration.instance().value("expressModule", this.configuration);
        }
    }, {
        key: "expressPort",
        get: function () {
            return Configuration.instance().value("expressPort", this.configuration);
        }
    }, {
        key: "filter",
        get: function () {
            return Configuration.instance().value("filter", this.configuration);
        }
    }, {
        key: "voiceId",
        get: function () {
            return Configuration.instance().value("voiceId", this.configuration);
        }
    }, {
        key: "intentSchema",
        get: function () {
            return Configuration.instance().value("intentSchema", this.configuration);
        }
    }, {
        key: "exclude",
        get: function () {
            return Configuration.instance().value("exclude", this.configuration);
        }
    }, {
        key: "include",
        get: function () {
            return Configuration.instance().value("include", this.configuration);
        }
    }, {
        key: "sampleUtterances",
        get: function () {
            return Configuration.instance().value("sampleUtterances", this.configuration);
        }
    }, {
        key: "skillURL",
        get: function () {
            return Configuration.instance().value("skillURL", this.configuration);
        }
    }, {
        key: "actionURL",
        get: function () {
            return Configuration.instance().value("actionURL", this.configuration);
        }
    }, {
        key: "homophones",
        get: function () {
            return Configuration.instance().value("homophones", this.configuration);
        }
    }, {
        key: "accessToken",
        get: function () {
            return Configuration.instance().value("accessToken", this.configuration);
        }
    }, {
        key: "address",
        get: function () {
            return Configuration.instance().value("address", this.configuration);
        }
    }, {
        key: "applicationId",
        get: function () {
            return Configuration.instance().value("applicationId", this.configuration);
        }
    }, {
        key: "configuration",
        get: function () {
            return this._configuration;
        }
    }, {
        key: "deviceId",
        get: function () {
            return Configuration.instance().value("deviceId", this.configuration);
        }
    }, {
        key: "dynamo",
        get: function () {
            return Configuration.instance().value("dynamo", this.configuration);
        }
    }, {
        key: "ignoreExternalErrors",
        get: function () {
            return Configuration.instance().value("ignoreExternalErrors", this.configuration, false);
        }
    }, {
        key: "fileName",
        get: function () {
            return this._fileName;
        },
        set: function (name) {
            this._fileName = name;
        }
    }, {
        key: "handler",
        get: function () {
            var handlerPath = Configuration.instance().value("handler", this.configuration);
            if (handlerPath) {
                return this.resolvePath(handlerPath);
            }
            return "./index.handler";
        }
    }, {
        key: "interactionModel",
        get: function () {
            if (this.testDirectory) {
                return `${this.testDirectory}/models/${this.locale}.json`;
            }
            var defaultValue = `./models/${this.locale}.json`;
            var interactionModelPath = Configuration.instance().value("interactionModel", this.configuration);
            if (interactionModelPath) {
                return this.resolvePath(interactionModelPath);
            }
            return defaultValue;
        }
    }, {
        key: "invocationName",
        get: function () {
            return Configuration.instance().value("invocationName", this.configuration);
        }
    }, {
        key: "invoker",
        get: function () {
            return Configuration.instance().value("invoker", this.configuration);
        }
    }, {
        key: "locale",
        get: function () {
            if (this._currentLocale) return this._currentLocale;
            return Configuration.instance().value("locale", this.configuration);
        }
    }, {
        key: "platform",
        get: function () {
            return Configuration.instance().value("platform", this.configuration, "alexa");
        }
    }, {
        key: "type",
        get: function () {
            return Configuration.instance().value("type", this.configuration, "unit");
        }
    }, {
        key: "locales",
        get: function () {
            return Configuration.instance().value("locales", this.configuration);
        }
    }, {
        key: "shortFileName",
        get: function () {
            return path.basename(this._fileName);
        }
    }, {
        key: "testDirectory",
        get: function () {
            /// By default we look for files in the root folder
            /// if testDirectory is set, this path will be used instead
            /// right now useful for testing
            return Configuration.instance().value("testDirectory", this.configuration);
        }
    }, {
        key: "directory",
        get: function () {
            return path.dirname(this._fileName);
        }
    }, {
        key: "tests",
        get: function () {
            return this._tests;
        },
        set: function (tests) {
            this._tests = tests;
        }
    }, {
        key: "localizedValues",
        get: function () {
            return this._localizedValues;
        },
        set: function (localizedValues) {
            this._localizedValues = localizedValues;
        }
    }, {
        key: "skillId",
        get: function () {
            return Configuration.instance().value("skillId", this.configuration);
        }
    }, {
        key: "trace",
        get: function () {
            return Configuration.instance().value("trace", this.configuration);
        }
    }, {
        key: "userId",
        get: function () {
            return Configuration.instance().value("userId", this.configuration);
        }
    }, {
        key: "supportedInterfaces",
        get: function () {
            var audioPlayerSupported = true;
            var displaySupported = true;
            var videoAppSupported = true;
            var interfacesList = Configuration.instance().value("supportedInterfaces", this.configuration);
            if (interfacesList) {
                var interfaces = interfacesList.split(",").map(i => i.trim());
                audioPlayerSupported = interfaces.indexOf("AudioPlayer") >= 0;
                displaySupported = interfaces.indexOf("Display") >= 0;
                videoAppSupported = interfaces.indexOf("VideoApp") >= 0;
            }
            return { audioPlayerSupported, displaySupported, videoAppSupported };
        }
    }, {
        key: "virtualDeviceToken",
        get: function () {
            var platform = this.platform;
            var locale = this.locale;
            var token = Configuration.instance().value("virtualDeviceToken", this.configuration);
            if (typeof token === "object") {
                if (platform in token) {
                    if (typeof token[platform] === "object" && locale in token[platform]) {
                        return token[platform][locale];
                    } else if (typeof token[platform] === "string") {
                        return token[platform];
                    }
                }
            } else if (typeof token === "string") {
                return token;
            }
            return undefined;
        }
    }, {
        key: "batchEnabled",
        get: function () {
            return Configuration.instance().value("batchEnabled", this.configuration, true);
        }
    }, {
        key: "ignoreProperties",
        get: function () {
            return Configuration.instance().value("ignoreProperties", this.configuration, {});
        }
    }, {
        key: "currentLocale",
        set: function (currentLocale) {
            this._currentLocale = currentLocale;
        }
    }, {
        key: "rawTestContent",
        get: function () {
            return this._rawTestContent;
        },
        set: function (rawTestContent) {
            this._rawTestContent = rawTestContent;
        }
    }]);

    return TestSuite;
}();