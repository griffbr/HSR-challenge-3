var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Assertion = require("./Assertion");
var Configuration = require("../runner/Configuration");
var Expression = require("./Expression");
var fs = require("fs");
var ParserError = require("./ParserError");
var Test = require("./Test");
var TestInteraction = require("./TestInteraction");
var TestSuite = require("./TestSuite");
var Util = require("../util/Util");
var yaml = require("js-yaml-bespoken");

module.exports = function () {
    function TestParser(fileName) {
        _classCallCheck(this, TestParser);

        this.fileName = fileName;
        if (this.fileName) {
            this.contents = fs.readFileSync(this.fileName, "utf8");
        }
    }

    _createClass(TestParser, [{
        key: "load",
        value: function load(contents) {
            this.contents = contents;
        }

        // Parses a test file and returns a test suite

    }, {
        key: "parse",
        value: function parse() {
            try {
                var contents = this.findReplace(this.contents);
                var documents = yaml.loadAll(contents);
                var configuration = void 0;
                var tests = documents;
                if (documents.length > 1 && documents[0].configuration) {
                    if (!Util.isObject(documents[0].configuration)) {
                        throw ParserError.globalError(this.fileName, "Configuration element is not an object", Util.extractLine(documents[0].configuration));
                    }
                    configuration = documents[0].configuration;
                    tests = documents.slice(1);
                }

                var suite = new TestSuite(this.fileName, configuration);
                suite.tests = this.parseTests(suite, tests);
                suite.rawTestContent = this.contents;
                return suite;
            } catch (e) {
                throw e;
            }
        }
    }, {
        key: "parseTests",
        value: function parseTests(suite, rawTests) {
            var tests = [];
            var testCount = 0;
            for (var test of rawTests) {
                testCount++;
                var parsedTest = this.parseTest(suite, test, testCount);
                if (parsedTest) {
                    tests.push(parsedTest);
                }
            }

            return tests;
        }
    }, {
        key: "parseTest",
        value: function parseTest(suite, rawTest, testIndex) {
            //If this is not an array, skip it
            if (!Array.isArray(rawTest)) {
                return undefined;
            }

            // The rawTest element is just an array of interactions
            // Optionally preceded by metadata about the test
            var rawInteractions = rawTest;
            if (rawInteractions.length == 0) {
                return new Test(suite, undefined, []);
            }

            // We need to pull out the first key of the first line of the test
            // If there is any metadata, this is where it is

            var testMeta = "Test " + testIndex;
            var only = false;
            var skipped = false;
            var tags = [];
            var filteredInteractions = [];

            for (var i = 0; i < rawInteractions.length; i++) {
                var isSpecialInteraction = false;

                var currentInteraction = rawInteractions[i];

                var interactionKeys = Object.keys(currentInteraction);

                // If the first or second element of the first interaction is "test", "test.only", or "test.skip", it is metadata
                if (i < 2 && interactionKeys.length > 0 && ["test", "test.only", "test.skip"].includes(interactionKeys[0])) {
                    isSpecialInteraction = true;
                    testMeta = currentInteraction[interactionKeys[0]];
                    if (interactionKeys[0] === "test.only") {
                        only = true;
                    } else if (interactionKeys[0] === "test.skip") {
                        skipped = true;
                    }
                }

                // If the first or second element of the first interaction is "tag", it is metadata
                if (i < 2 && interactionKeys.length > 0 && ["tags"].includes(interactionKeys[0])) {
                    isSpecialInteraction = true;

                    var tagsString = currentInteraction[interactionKeys[0]];
                    if (Util.isString(tagsString)) {
                        tags = tagsString.split(",").map(tag => tag.trim());
                    }
                }

                if (!isSpecialInteraction) {
                    filteredInteractions.push(currentInteraction);
                }
            }

            var test = new Test(suite, testMeta, []);
            for (var _i = 0; _i < filteredInteractions.length; _i++) {
                var rawInteraction = filteredInteractions[_i];
                test.interactions.push(this.parseInteraction(test, rawInteraction, _i));
            }

            test.skip = skipped;
            test.only = only;

            if (tags.length) {
                test.tags = tags;
            }

            test.validate();
            return test;
        }
    }, {
        key: "parseInteraction",
        value: function parseInteraction(test, interactionJSON, index) {
            var interaction = new TestInteraction(test);

            // If we have an object, we process it - alternatively the interaction could just be a string
            //  Such as "- yes" without any assertions
            if (Util.isObject(interactionJSON)) {
                interaction.utterance = Object.keys(interactionJSON)[0];
                var elements = interactionJSON[interaction.utterance];
                interaction.lineNumber = Util.extractLine(elements);
                // Just because we have an object, we might have a "bad" object
                // Like so: - yes: "okay" - our old-style syntax
                // We just ignore these cases for now
                if (Array.isArray(elements)) {
                    for (var element of elements) {
                        if (Util.isValueType(element)) {
                            interaction.assertions.push(this.parseStringAssertion(interaction, element));
                        } else {
                            if (element.intent) {
                                interaction.intent = element.intent.valueOf();

                                // Treat any other keys as slots
                                var slots = Util.cleanObject(element);
                                delete slots.intent;
                                interaction.slots = slots;
                            } else if (element.slots) {
                                interaction.slots = Util.cleanObject(element.slots);
                            } else if (element.label) {
                                interaction.label = Util.cleanObject(element.label);
                            } else if (Expression.isExpression(element)) {
                                interaction.expressions.push(new Expression(element));
                            } else {
                                // Must be an assertion otherwise
                                interaction.assertions.push(this.parseObjectAssertion(interaction, element));
                            }
                        }
                    }
                } else if (elements) {
                    var operator = "==";
                    if (Util.isString(elements) && elements.startsWith("/")) {
                        operator = "=~";
                    }
                    interaction.assertions.push(new Assertion(interaction, "prompt", operator, elements));
                }
            } else {
                interaction.utterance = interactionJSON;
                interaction.lineNumber = Util.extractLine(interactionJSON);
            }
            interaction.relativeIndex = index;
            return interaction;
        }
    }, {
        key: "parseObjectAssertion",
        value: function parseObjectAssertion(interaction, element) {
            // Should have just one key
            var path = Object.keys(element)[0];
            var value = element[path];
            var operator = "==";
            // If the value starts with /, then it must be regular expression
            if (Util.isString(value) && value.trim().startsWith("/")) {
                operator = "=~";
            }

            var assertion = new Assertion(interaction, path, operator, value);
            assertion.validate();
            assertion.lineNumber = Util.extractLine(value);
            return assertion;
        }
    }, {
        key: "parseStringAssertion",
        value: function parseStringAssertion(interaction, assertionString) {
            var path = void 0;
            var operator = void 0;
            var value = void 0;

            // Special handling for exit
            if (assertionString.trim() === "exit") {
                return new Assertion(interaction, "exit");
            }

            if (assertionString.indexOf(" ") === -1) {
                throw ParserError.interactionError(interaction, "Invalid assertion: " + assertionString, Util.extractLine(assertionString));
            }

            var parts = assertionString.split(/ +/);
            path = parts[0];
            operator = parts[1];
            value = parts.slice(2).join(" ");

            var assertion = new Assertion(interaction, path, operator, value);
            assertion.lineNumber = Util.extractLine(assertionString);
            assertion.validate();
            return assertion;
        }
    }, {
        key: "findReplace",
        value: function findReplace(script) {
            var findReplaceMap = Configuration.instance() && Configuration.instance().findReplaceMap();
            if (!findReplaceMap) return script;
            for (var find of Object.keys(findReplaceMap)) {
                var value = findReplaceMap[find];
                script = script.split(find).join(value);
            }
            return script;
        }
    }]);

    return TestParser;
}();