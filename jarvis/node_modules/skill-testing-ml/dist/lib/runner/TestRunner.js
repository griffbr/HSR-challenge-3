var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var chalk = require("chalk");
var Configuration = require("./Configuration");
var CONSTANTS = require("../util/Constants");
var FrameworkError = require("../util/FrameworkError");
var fs = require("fs");
var InteractionResult = require("../test/TestResult").InteractionResult;
var TestParser = require("../test/TestParser");
var TestResult = require("../test/TestResult").TestResult;
var Util = require("../util/Util");

module.exports = function () {
    function TestRunner(config) {
        _classCallCheck(this, TestRunner);

        this._config = config;
        this._subscribers = { message: [], result: [] };
    }

    _createClass(TestRunner, [{
        key: "run",
        value: (() => {
            var _ref = _asyncToGenerator(function* (testFile, context) {
                var _this = this;

                return new Promise(function (resolve, reject) {
                    fs.readFile(testFile, "utf8", function (error, data) {
                        if (error) {
                            reject(error);
                        }

                        try {
                            var testSuite = _this.parseContents(testFile, data);
                            resolve(_this.runSuite(testSuite, context));
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            });

            function run(_x, _x2) {
                return _ref.apply(this, arguments);
            }

            return run;
        })()
    }, {
        key: "runSuite",
        value: (() => {
            var _ref2 = _asyncToGenerator(function* (testSuite, context) {
                var _this2 = this;

                // This may have already been called, but needs to be called again inside of the Jest runner
                yield Configuration.configure(this._config);
                yield testSuite.loadLocalizedValues();
                var locales = testSuite.locales;
                if (locales) {
                    var localesList = locales.split(",").map(function (l) {
                        return l.trim();
                    });
                    var results = yield Promise.all(localesList.map(function (locale) {
                        return _this2.runSuiteForLocale(testSuite, context, locale);
                    }));
                    results = [].concat.apply([], results);
                    return results;
                } else {
                    return yield this.runSuiteForLocale(testSuite, context, testSuite.locale);
                }
            });

            function runSuite(_x3, _x4) {
                return _ref2.apply(this, arguments);
            }

            return runSuite;
        })()
    }, {
        key: "runSuiteForLocale",
        value: (() => {
            var _ref3 = _asyncToGenerator(function* (testSuite, context, locale) {
                if (!locale) {
                    throw new FrameworkError("Locale must be defined either in the testing.json or the test file itself under the config element");
                }

                var testSuiteWithLocale = this.parseContents(testSuite.fileName, testSuite.rawTestContent);
                testSuiteWithLocale.currentLocale = locale;
                testSuiteWithLocale.localizedValues = testSuite.localizedValues;

                if (testSuiteWithLocale.filterObject() && testSuiteWithLocale.filterObject().onTestSuiteStart) {
                    yield testSuiteWithLocale.filterObject().onTestSuiteStart(testSuiteWithLocale);
                }

                var invokerName = this.getInvoker(testSuite);
                var InvokerClass = require("./" + invokerName);
                var invoker = new InvokerClass(this);
                try {
                    yield invoker.before(testSuiteWithLocale);
                } catch (error) {
                    this.emit("result", error);
                    throw error;
                }
                var batchEnabled = testSuiteWithLocale.batchEnabled;

                testSuiteWithLocale.processIncludedAndExcludedTags();
                testSuiteWithLocale.processOnlyFlag();
                var testResults = [];

                for (var test of testSuiteWithLocale.tests) {
                    if (testSuite.filterObject() && testSuite.filterObject().onTestStart) {
                        yield testSuite.filterObject().onTestStart(test);
                    }

                    yield invoker.beforeTest(test);

                    var testResult = new TestResult(test);
                    testResults.push(testResult);
                    if (test.skip) {
                        yield invoker.afterTest(test);
                        // if we skip we still need to do the after test in case is closing something like in VGA
                        continue;
                    }

                    // Process through the interactions
                    // If there is a goto or this is not a batch invoker, run them one-by-one
                    var results = void 0;
                    if (test.hasGoto || !(invoker.batchSupported() && batchEnabled)) {
                        results = yield this.sequentialRun(invoker, testSuiteWithLocale, test.interactions, context);
                    } else {
                        results = yield this.batchRun(invoker, testSuiteWithLocale, test.interactions, context);
                    }
                    testResult.interactionResults = results;
                    testResult.locale = locale;

                    yield invoker.afterTest(test);

                    if (testSuite.filterObject() && testSuite.filterObject().onTestEnd) {
                        yield testSuite.filterObject().onTestEnd(test, testResult);
                    }
                }

                yield invoker.after(testSuiteWithLocale);

                if (testSuite.filterObject() && testSuite.filterObject().onTestSuiteEnd) {
                    yield testSuite.filterObject().onTestSuiteEnd(testResults);
                }

                return testResults;
            });

            function runSuiteForLocale(_x5, _x6, _x7) {
                return _ref3.apply(this, arguments);
            }

            return runSuiteForLocale;
        })()
    }, {
        key: "batchRun",
        value: (() => {
            var _ref4 = _asyncToGenerator(function* (invoker, testSuite, interactions, context) {
                var _this3 = this;

                var responses = yield invoker.invokeBatch(interactions);

                // Add short-hand properties to each response
                responses.forEach(function (response) {
                    return response.inject();
                });

                // Turn the responses into interaction results
                var interactionResults = responses.map(function (response) {
                    return _this3.processResponse(response, testSuite, context);
                });
                return interactionResults;
            });

            function batchRun(_x8, _x9, _x10, _x11) {
                return _ref4.apply(this, arguments);
            }

            return batchRun;
        })()
    }, {
        key: "sequentialRun",
        value: (() => {
            var _ref5 = _asyncToGenerator(function* (invoker, testSuite, interactions, context) {
                var goto = void 0;
                var results = [];
                for (var interaction of interactions) {
                    // If a goto is set, keep skipping until we match it
                    if (goto) {
                        if (goto === interaction.utterance || goto == interaction.label) {
                            goto = undefined;
                        } else {
                            continue;
                        }
                    }
                    this.emit("message", undefined, interaction.toDTO(), context);
                    var response = void 0;
                    try {
                        response = yield invoker.invoke(interaction);
                    } catch (e) {
                        var resultOnException = this.handleException(interaction, e);
                        results.push(resultOnException);
                        var interactionDto = interaction.toDTO();
                        interactionDto.result = resultOnException.toDTO();
                        this.emit("result", undefined, interactionDto, context);
                        continue;
                    }

                    // Add short-hand properties to the response
                    response.inject();

                    var interactionResult = this.processResponse(response, testSuite, context);
                    if (interactionResult.goto) {
                        // If this result is a goto, set the goto label
                        goto = interactionResult.goto;
                    }

                    results.push(interactionResult);
                    if (interactionResult.exited) {
                        // If this is an exit, stop processing
                        break;
                    }
                }

                return results;
            });

            function sequentialRun(_x12, _x13, _x14, _x15) {
                return _ref5.apply(this, arguments);
            }

            return sequentialRun;
        })()
    }, {
        key: "processResponse",
        value: function processResponse(response, testSuite, context) {
            var interaction = response.interaction;

            // We check if a filter object is defined
            // If so, it gives the test writer a chance to make changes to the response
            if (testSuite.filterObject() && testSuite.filterObject().onResponse) {
                testSuite.filterObject().onResponse(interaction.test, response.json);
            }

            var result = new InteractionResult(interaction);
            for (var assertion of interaction.assertions) {
                if (assertion.exit) {
                    result = new InteractionResult(interaction, assertion);
                    break;
                }

                if (!response.supported(assertion.path)) {
                    continue;
                }

                var passed = assertion.evaluate(response);
                if (passed) {
                    // If this is a goto, stop processing assertions here
                    if (assertion.goto) {
                        result = new InteractionResult(interaction, assertion);
                        break;
                    }
                } else if (!assertion.goto) {
                    // If it did not pass, and was NOT a goto, then it is a failure
                    // We do not consider tests that end in goto statements failures if they do not match
                    var error = assertion.toString(response.json, response.errorOnProcess);
                    result = new InteractionResult(interaction, assertion, error, response.errorOnProcess);
                    break;
                }
            }

            if (testSuite.trace) {
                // eslint-disable-next-line no-console
                console.log(chalk.cyan("Response Envelope:\n" + JSON.stringify(response.json, null, 2)));
            }
            var interactionDto = interaction.toDTO();
            interactionDto.result = result.toDTO();

            this.emit("result", undefined, interactionDto, context);
            return result;
        }
    }, {
        key: "parseContents",
        value: function parseContents(fileName, testContents) {
            var parser = new TestParser();
            parser.fileName = fileName;
            parser.load(testContents);
            return parser.parse();
        }

        // Method that can be used to print out the request payload, if available
        // TODO - should this be done with an event emitter instead?

    }, {
        key: "filterRequest",
        value: function filterRequest(interaction, request) {
            interaction.applyExpressions(request);

            // We check if a filter object is defined
            // If so, it gives the test writer a chance to make changes to the request
            var testSuite = interaction.test.testSuite;
            if (testSuite.filterObject() && testSuite.filterObject().onRequest) {
                testSuite.filterObject().onRequest(interaction.test, request);
            }

            if (testSuite.trace) {
                var test = interaction.test;
                // eslint-disable-next-line no-console
                console.log("File: " + testSuite.shortFileName + " Test: " + test.description + " Utterance: " + interaction.utterance);

                // eslint-disable-next-line no-console
                console.log(chalk.hex("#ff6633")("Request Envelope:\n" + JSON.stringify(request, null, 2)));
            }
        }
    }, {
        key: "handleException",
        value: function handleException(interaction, e) {
            var testSuite = interaction.test.testSuite;
            if (e.message && (e.message.startsWith("Unable to match utterance:") || e.message.startsWith("Interaction model has no intentName named"))) {
                var message = Util.errorMessageWithLine(e.message, testSuite.fileName, interaction.lineNumber);
                return new InteractionResult(interaction, undefined, message);
            } else {
                if (e instanceof FrameworkError) {
                    return new InteractionResult(interaction, undefined, e.message);
                } else if (e.message) {
                    return new InteractionResult(interaction, undefined, e.message + "\n" + e.stack);
                } else {
                    return new InteractionResult(interaction, undefined, e.toString());
                }
            }
        }
    }, {
        key: "subscribe",
        value: function subscribe(event, callback) {
            if (event in this._subscribers) {
                this._subscribers[event].push(callback);
            }
        }
    }, {
        key: "unsubscribe",
        value: function unsubscribe(event) {
            this._subscribers[event] = [];
        }
    }, {
        key: "emit",
        value: function emit(event, error, data, context) {
            if (event in this._subscribers) {
                this._subscribers[event].forEach(subscriber => {
                    subscriber(error, data, context);
                });
            }
        }
    }, {
        key: "getInvoker",
        value: function getInvoker(testSuite) {
            var invoker = testSuite.invoker;
            if (invoker) {
                return invoker;
            }
            var type = testSuite.type;
            var platform = testSuite.platform;

            if (type === CONSTANTS.TYPE.e2e) {
                return CONSTANTS.INVOKER.virtualDeviceInvoker;
            } else if (type === CONSTANTS.TYPE.simulation) {
                return CONSTANTS.INVOKER.SMAPIInvoker;
            } else if (type === CONSTANTS.TYPE.unit) {
                if (platform === CONSTANTS.PLATFORM.alexa) {
                    return CONSTANTS.INVOKER.virtualAlexaInvoker;
                } else if (platform === CONSTANTS.PLATFORM.google) {
                    return CONSTANTS.INVOKER.virtualGoogleAssistantInvoker;
                }
            }

            throw new FrameworkError("valid type and platform must be defined either in the testing.json or the test file itself under the config element");
        }
    }, {
        key: "configuration",
        get: function () {
            return this._config;
        }
    }]);

    return TestRunner;
}();