var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _ = require("lodash");
var CONSTANTS = require("../util/Constants");
var debug = require("../util/Debug");
var FrameworkError = require("../util/FrameworkError");
var Invoker = require("./Invoker").Invoker;
var InvokerResponse = require("./Invoker").InvokerResponse;
var VirtualDevice = require("virtual-device-sdk").VirtualDevice;

module.exports = function (_Invoker) {
    _inherits(VirtualDeviceInvoker, _Invoker);

    function VirtualDeviceInvoker(runner) {
        _classCallCheck(this, VirtualDeviceInvoker);

        return _possibleConstructorReturn(this, (VirtualDeviceInvoker.__proto__ || Object.getPrototypeOf(VirtualDeviceInvoker)).call(this, runner));
    }

    _createClass(VirtualDeviceInvoker, [{
        key: "batchSupported",
        value: function batchSupported() {
            return true;
        }
    }, {
        key: "before",
        value: function before(testSuite) {
            var locale = testSuite.locale || undefined;
            var voiceId = testSuite.voiceId || undefined;
            var virtualDeviceToken = testSuite.virtualDeviceToken;
            if (!virtualDeviceToken) {
                throw new FrameworkError("A valid virtualDeviceToken property must be defined either in the testing.json or the yml test file under the config element");
            }

            this._virtualDevice = new VirtualDevice(virtualDeviceToken, locale, voiceId);

            var homophones = testSuite.homophones;
            if (homophones) {
                var keys = Object.keys(homophones);
                for (var key of keys) {
                    this._virtualDevice.addHomophones(key, homophones[key]);
                }
            }
        }
    }, {
        key: "invokeBatch",
        value: (() => {
            var _ref = _asyncToGenerator(function* (interactions) {
                var messages = [];

                // Keep an array of the actual interactions sent, as some may be skipped
                var messageInteractions = [];
                for (var interaction of interactions) {
                    var utterance = interaction.utterance;
                    if (!utterance) {
                        continue;
                    }

                    var message = {
                        phrases: [],
                        text: utterance
                    };
                    messageInteractions.push(interaction);

                    if (interaction.assertions) {
                        for (var assertion of interaction.assertions) {
                            // If this is a check on the prompt or the transcript
                            //  we add the expected value as a phrase - this helps with speech recognition
                            if ((assertion.path === "prompt" || assertion.path === "transcript") && (assertion.operator === "==" || assertion.operator === "=~")) {
                                // Need to check if this is an array - the prompt assertions can specify a collection of strings
                                if (Array.isArray(assertion.value)) {
                                    message.phrases = message.phrases.concat(assertion.value);
                                } else {
                                    message.phrases.push(assertion.value);
                                }
                            }
                        }
                    }

                    messages.push(message);
                }

                var results = new Array(messages.length);
                var errorOnProcess = undefined;
                var enableDebug = true;
                if (messages.length > 0) {
                    try {
                        results = yield this._virtualDevice.batchMessage(messages, enableDebug);
                    } catch (error) {
                        var parsedError = this.parseError(error);
                        if (parsedError && parsedError.results) {
                            results = parsedError.results;
                        } else {
                            debug("Error: " + JSON.stringify(error));
                            results.fill({});
                            errorOnProcess = this.getError(error);
                        }
                    }
                }

                var responses = [];
                for (var i = 0; i < results.length; i++) {
                    var virtualDeviceResponse = new VirtualDeviceResponse(messageInteractions[i], results[i]);
                    if (errorOnProcess || results[i].error) {
                        virtualDeviceResponse.errorOnProcess = errorOnProcess || results[i].error.message;
                        responses.push(virtualDeviceResponse);
                        break;
                    }
                    responses.push(virtualDeviceResponse);
                }

                if (this._virtualDevice.waitForSessionToEnd) yield this._virtualDevice.waitForSessionToEnd();
                return responses;
            });

            function invokeBatch(_x) {
                return _ref.apply(this, arguments);
            }

            return invokeBatch;
        })()
    }, {
        key: "invoke",
        value: (() => {
            var _ref2 = _asyncToGenerator(function* (interaction) {
                if (!interaction.utterance) {
                    return;
                }

                var message = {
                    phrases: [],
                    text: interaction.utterance
                };

                if (interaction.assertions) {
                    for (var assertion of interaction.assertions) {
                        // If this is a check on the prompt or the transcript
                        //  we add the expected value as a phrase - this helps with speech recognition
                        if ((assertion.path === "prompt" || assertion.path === "transcript") && (assertion.operator === "==" || assertion.operator === "=~")) {
                            // Need to check if this is an array - the prompt assertions can specify a collection of strings
                            if (Array.isArray(assertion.value)) {
                                message.phrases = message.phrases.concat(assertion.value);
                            } else {
                                message.phrases.push(assertion.value);
                            }
                        }
                    }
                }

                var results = new Array(1);
                var errorOnProcess = undefined;
                try {
                    results = yield this._virtualDevice.batchMessage([message], false);
                } catch (error) {
                    var parsedError = this.parseError(error);
                    if (parsedError && parsedError.results) {
                        results = parsedError.results;
                    } else {
                        debug("Error: " + JSON.stringify(error));
                        results.fill({});
                        errorOnProcess = this.getError(error);
                    }
                }
                var virtualDeviceResponse = new VirtualDeviceResponse(interaction, results[0]);
                if (errorOnProcess) {
                    virtualDeviceResponse.errorOnProcess = errorOnProcess;
                    return virtualDeviceResponse;
                }

                return virtualDeviceResponse;
            });

            function invoke(_x2) {
                return _ref2.apply(this, arguments);
            }

            return invoke;
        })()
    }, {
        key: "getError",
        value: function getError(error) {
            var objectError = undefined;
            try {
                objectError = JSON.parse(error);
            } catch (_e) {
                objectError = error;
            }

            if (typeof objectError === "string") {
                return objectError;
            } else if (typeof objectError === "object") {
                if (objectError.error) {
                    if (typeof objectError.error === "string") {
                        return objectError.error;
                    } else if (Array.isArray(objectError.error)) {
                        return objectError.error.join(", ");
                    }
                }
                return "Error description missing.";
            }
        }
    }, {
        key: "parseError",
        value: function parseError(error) {
            try {
                return JSON.parse(error);
            } catch (error) {
                return undefined;
            }
        }
    }]);

    return VirtualDeviceInvoker;
}(Invoker);

var VirtualDeviceResponse = function (_InvokerResponse) {
    _inherits(VirtualDeviceResponse, _InvokerResponse);

    function VirtualDeviceResponse(interaction, sourceJSON) {
        _classCallCheck(this, VirtualDeviceResponse);

        return _possibleConstructorReturn(this, (VirtualDeviceResponse.__proto__ || Object.getPrototypeOf(VirtualDeviceResponse)).call(this, interaction, sourceJSON));
    }

    _createClass(VirtualDeviceResponse, [{
        key: "cardContent",
        value: function cardContent() {
            return _.get(this.json, "card.textField");
        }
    }, {
        key: "cardImageURL",
        value: function cardImageURL() {
            return _.get(this.json, "card.imageURL");
        }
    }, {
        key: "cardTitle",
        value: function cardTitle() {
            return _.get(this.json, "card.mainTitle");
        }
    }, {
        key: "prompt",
        value: function prompt() {
            return _.get(this.json, "transcript");
        }
    }, {
        key: "reprompt",
        value: function reprompt() {
            return undefined;
        }
    }, {
        key: "sessionEnded",
        value: function sessionEnded() {
            return undefined;
        }
    }, {
        key: "supported",
        value: function supported(jsonPath) {
            var platform = _.get(this._interaction, "test.testSuite.platform");
            var ignorePropertiesRaw = _.get(this._interaction, "test.testSuite.ignoreProperties");

            var ignoredProperties = [];
            if (ignorePropertiesRaw && ignorePropertiesRaw[platform] && ignorePropertiesRaw[platform]["type"] == "e2e") {
                ignoredProperties = ignorePropertiesRaw[platform]["paths"].split(",").map(x => x.trim());
            }

            if (platform === CONSTANTS.PLATFORM.google) {
                ignoredProperties.push("card.type");
            }

            if (ignoredProperties.includes(jsonPath)) {
                return false;
            }

            var supportedProperties = ["cardContent", "cardImageURL", "cardTitle", "prompt"];
            if (platform === CONSTANTS.PLATFORM.alexa) {
                supportedProperties.push("streamURL");
            }

            var includeBasicPaths = supportedProperties.includes(jsonPath);
            var isDisplayPath = jsonPath.startsWith("display");
            var isRawPath = jsonPath.startsWith("raw");
            var isCardPath = jsonPath.startsWith("card");

            return includeBasicPaths || isDisplayPath || isRawPath || isCardPath;
        }

        // eslint-disable-next-line no-unused-vars

    }, {
        key: "ignoreCase",
        value: function ignoreCase(jsonPath) {
            return ["prompt", "transcript"].includes(jsonPath);
        }
    }]);

    return VirtualDeviceResponse;
}(InvokerResponse);