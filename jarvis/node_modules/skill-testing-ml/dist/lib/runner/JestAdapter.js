function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// We use to print out errors on the console
// Got it from here:
//  https://github.com/facebook/jest/blob/master/packages/jest-jasmine2/src/reporter.js#L103
var Configuration = require("./Configuration");
var debug = require("../util/Debug");
var JestMessageUtil = require("jest-message-util");
var Path = require("path");
var Util = require("../util/Util");

// Entry point for Jest to invoke the VirtualAlexaRunner
// Converts between VirtualAlexa responses and Jest responses
module.exports = (() => {
    var _ref = _asyncToGenerator(function* (globalConfig, config, environment, runtime, testPath) {
        debug("Test: " + testPath);
        var runnerPath = Path.join(__dirname, "TestRunner.js");
        debug("RunnerPath: " + runnerPath);
        // It is necessary we call in this way to get code coverage - we use the Jest module loader
        var TestRunner = runtime.requireModule(runnerPath);

        // This needs to be called here, as well as in the CLI classes, because Jest spawns a new process
        yield Configuration.configure();
        var runner = new TestRunner(Configuration.instance().skillTestingConfig());

        var jestResults = void 0;
        var passing = 0;
        var failing = 0;
        var pending = 0;

        var doResultsHaveErrorMessages = false;

        try {
            var results = yield runner.run(testPath);
            jestResults = transformResults(results);

            // Summarize the results
            for (var result of results) {
                if (result.skipped) {
                    pending++;
                } else if (result.passed) {
                    passing++;
                } else {
                    failing++;
                }
            }

            doResultsHaveErrorMessages = jestResults.some(function (jestResult) {
                return jestResult.failureMessages && jestResult.failureMessages.length;
            });
        } catch (e) {
            failing = 1;
            jestResults = [asJestResult(e.test, e.message, e.interaction)];
        }

        var allTestsSkipped = failing + passing === 0;

        // This means tests are skipped by ignoring external errors and everything failed
        if (allTestsSkipped && doResultsHaveErrorMessages) {
            failing = 1;
        }

        var failureMessage = JestMessageUtil.formatResultsErrors(jestResults, config, globalConfig, testPath);

        return {
            console: null,
            displayName: "Display name",
            failureMessage,
            leaks: false,
            memoryUsage: 0,
            numFailingTests: failing,
            numPassingTests: passing,
            numPendingTests: pending,
            skipped: !doResultsHaveErrorMessages && allTestsSkipped,
            snapshot: {
                added: 0,
                fileDeleted: false,
                matched: 0,
                unchecked: 0,
                uncheckedKeys: [],
                unmatched: 0,
                updated: 0
            },
            sourceMaps: {},
            testExecError: undefined,
            testFilePath: testPath,
            testResults: jestResults
        };
    });

    function testRunner(_x, _x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
    }

    return testRunner;
})();

function transformResults(results) {
    var jestResults = [];
    // Create an array of Jest results - we transform our results into this
    for (var result of results) {
        if (result.interactionResults.length > 0) {
            for (var interactionResult of result.interactionResults) {
                var interactionErrors = [];
                if (interactionResult.error) {
                    interactionErrors.push(interactionResult.errorMessage);
                }

                var jestResult = asJestResult(result.test, interactionResult.error, interactionResult.interaction, result.locale, result.skipped, interactionResult.timestamp);
                jestResults.push(jestResult);
            }
        } else {
            var _jestResult = asJestResult(result.test, undefined, undefined, undefined, result.skipped);
            jestResults.push(_jestResult);
        }
    }
    return jestResults;
}

function asJestResult(test, errorMessage, interaction, locale, skipped, timestamp) {
    var errors = [];
    var status = "passed";

    if (errorMessage) {
        var error = errorMessage;
        if (timestamp) {
            error = error + "\nTimestamp:\n\t";
            // eslint-disable-next-line spellcheck/spell-checker
            error = error + Util.formatDate(timestamp);
        }
        errors.push(error);
        status = "failed";
    }

    var ancestors = test ? [locale, test.description] : [];
    var title = interaction ? interaction.utterance : "Global";

    if (skipped) {
        status = "pending";
    }

    if (skipped && !errorMessage) {
        ancestors = [];
    }

    return {
        ancestorTitles: ancestors,
        failureMessages: errors,
        location: {
            column: 0,
            line: 0
        },
        numPassingAsserts: 0,
        status: status,
        title: title
    };
}