var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require("lodash");
var cosmiconfig = require("cosmiconfig");
var debug = require("../util/Debug");
var fs = require("fs");
var path = require("path");
var Util = require("../util/Util");

var SkillTestingDirectoryName = ".skillTesting";

module.exports = function () {
    function Configuration() {
        _classCallCheck(this, Configuration);
    }

    _createClass(Configuration, [{
        key: "load",


        // Load configuration
        //  json: json configuration
        //  pathName: path were the test files are located  
        value: (() => {
            var _ref = _asyncToGenerator(function* (json, pathName, cliOverrides) {
                if (json) {
                    this.configurationJSON = json;
                } else {
                    var searchPlaces = ["./test/unit/testing.json", "./test/unit/skill-testing.json", "./test/e2e/testing.json", "./test/e2e/skill-testing.json", "./test/testing.json", "./test/skill-testing.json", "testing.json", "skill-testing.json"];
                    if (pathName) {
                        searchPlaces.unshift(`${pathName}/testing.json`);
                        searchPlaces.unshift(`${pathName}/skill-testing.json`);
                    }
                    // Load the configuration file for skill-testing, if there is one
                    var configExplorer = cosmiconfig("skill-testing", { searchPlaces });
                    var skillConfigResult = yield configExplorer.search();
                    this.configurationJSON = skillConfigResult ? skillConfigResult.config : {};
                    this.configurationJSON.configurationPath = skillConfigResult && skillConfigResult.filepath;
                }

                var jestConfig = this.jestDefaults();
                // configurationPath has the location of testing.json if is found
                if (this.configurationJSON.configurationPath) {
                    // coverageDirectory works with relative paths, so we use path.relative to get a relative path. Ex:
                    // process.cwd(): /Users/bespoken/multi-locale-facts-sample-skill
                    // path.dirname(this.configurationJSON.configurationPath): /Users/bespoken/multi-locale-facts-sample-skill/test/unit
                    // relativePath: test/unit
                    var relativePath = path.relative(process.cwd(), path.dirname(this.configurationJSON.configurationPath));
                    relativePath = relativePath || ".";
                    jestConfig.coverageDirectory = path.normalize(`${relativePath}/coverage/`);
                }

                // Override jest values
                var jestOverrides = this.configurationJSON.jest;
                if (jestOverrides) {
                    for (var key of Object.keys(jestOverrides)) {
                        debug("JEST - Override " + key + ": " + jestOverrides[key]);
                        jestConfig[key] = jestOverrides[key];
                    }
                }

                this.configurationJSON.jest = jestConfig;
                this.overrideConfigurationWithEnvVariables();
                this.overrideConfigurationWithCli(cliOverrides);
            });

            function load(_x, _x2, _x3) {
                return _ref.apply(this, arguments);
            }

            return load;
        })()
    }, {
        key: "jestPath",
        value: function jestPath() {
            var defaultJestPath = path.join(__dirname, "../node_modules/.bin/jest");
            return this.json().jestPath ? this.json().jestPath : defaultJestPath;
        }
    }, {
        key: "jestConfig",
        value: function jestConfig() {
            return this.json().jest;
        }
    }, {
        key: "json",
        value: function json() {
            return this.configurationJSON;
        }
    }, {
        key: "jestDefaults",
        value: function jestDefaults() {
            // Get the skill testing jest delegate - relative to this file
            var testRunnerPath = path.join(__dirname, "../runner/JestAdapter.js");
            debug("JestTestRunner: " + testRunnerPath);

            // Configuration is a combination of Jest elements and Skill Testing ones
            return {
                collectCoverage: true,
                collectCoverageFrom: ["**/*.js", "!**/coverage/**", "!**/node_modules/**", "!**/vendor/**"],
                coverageDirectory: "./coverage/",
                moduleFileExtensions: ["ts", "js", "json", "node", "yml"],
                silent: false,
                testEnvironment: "node",
                testMatch: ["**/test/*.yml", "**/tests/*.yml", "**/*.e2e.yml", "**/*.spec.yml", "**/*.test.yml"],
                testPathIgnorePatterns: ["/coverage/", "/locales/", "/lambda/"],
                testRunner: testRunnerPath,
                testURL: "http://localhost/",
                verbose: true
            };
        }
    }, {
        key: "skillTestingConfig",
        value: function skillTestingConfig() {
            return this.json();
        }
    }, {
        key: "value",
        value: function value(propertyName, overrides, defaultValue) {
            if (overrides && propertyName in overrides) {
                return overrides[propertyName].valueOf();
            }

            if (propertyName in this.json()) {
                return this.json()[propertyName];
            }

            return defaultValue;
        }
    }, {
        key: "findReplaceMap",
        value: function findReplaceMap() {
            return this.value("findReplace", undefined, {});
        }
    }, {
        key: "overrideConfigurationWithEnvVariables",
        value: function overrideConfigurationWithEnvVariables() {
            for (var key of Object.keys(process.env)) {
                var value = _.get(this.configurationJSON, key);

                if (value) {
                    var newValue = process.env[key];
                    if (Util.isBoolean(newValue)) {
                        newValue = newValue === "true";
                    }
                    _.set(this.configurationJSON, key, newValue);
                }
            }
        }
    }, {
        key: "overrideConfigurationWithCli",
        value: function overrideConfigurationWithCli(cliOverrides) {
            if (!cliOverrides) return;
            for (var key of Object.keys(cliOverrides)) {
                var newValue = cliOverrides[key];
                if (newValue !== undefined) {
                    if (Util.isBoolean(newValue)) {
                        newValue = newValue === "true";
                    }
                    _.set(this.configurationJSON, key, newValue);
                }
            }
        }
    }], [{
        key: "skillTestingConfigDirectory",
        value: function skillTestingConfigDirectory() {
            return `${getUserHome()}/${SkillTestingDirectoryName}`;
        }
    }, {
        key: "skillTestingConfigPath",
        value: function skillTestingConfigPath() {
            return `${this.skillTestingConfigDirectory()}/config`;
        }
    }, {
        key: "saveConfig",
        value: function saveConfig(config = {}) {
            if (!fs.existsSync(this.skillTestingConfigDirectory())) {
                fs.mkdirSync(this.skillTestingConfigDirectory());
            }
            var configBuffer = new Buffer(JSON.stringify(config, null, 4) + "\n");
            fs.writeFileSync(this.skillTestingConfigPath(), configBuffer);
        }
    }, {
        key: "readConfig",
        value: function readConfig() {
            if (!fs.existsSync(this.skillTestingConfigPath())) {
                return undefined;
            }
            var data = fs.readFileSync(this.skillTestingConfigPath());
            var config = JSON.parse(data.toString());
            return config;
        }
    }, {
        key: "configure",
        value: (() => {
            var _ref2 = _asyncToGenerator(function* (json, pathName, cliOverrides, writeConfig) {
                if (writeConfig) {
                    this.saveConfig(cliOverrides);
                }
                if (Configuration.singleton) {
                    return;
                }
                Configuration.singleton = new Configuration();

                if (!cliOverrides) {
                    var savedConfig = this.readConfig();
                    if (savedConfig) {
                        cliOverrides = savedConfig;
                    }
                }

                return yield this.singleton.load(json, pathName, cliOverrides);
            });

            function configure(_x4, _x5, _x6, _x7) {
                return _ref2.apply(this, arguments);
            }

            return configure;
        })()
    }, {
        key: "reset",
        value: (() => {
            var _ref3 = _asyncToGenerator(function* () {
                Configuration.singleton = undefined;
            });

            function reset() {
                return _ref3.apply(this, arguments);
            }

            return reset;
        })()
    }, {
        key: "instance",
        value: function instance() {
            return Configuration.singleton;
        }
    }]);

    return Configuration;
}();

// Internet code:
//  http://stackoverflow.com/questions/9080085/node-js-find-home-directory-in-platform-agnostic-way
function getUserHome() {
    return process.env[process.platform === "win32" ? "USERPROFILE" : "HOME"];
}